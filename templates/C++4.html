{% extends "layout.html" %} {% block body %}

<html>

<head>
    <title>C++ Tutorial | C++ Tutorial - E-Learning</title>
    <link href="{{url_for('static', filename='ContentAsset/new.css')}}" rel="stylesheet">
</head>


<body>
    <br>
    <br>
     
    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
                    <br>
                    <br>

                        <h1 class="h1">C++ OOPs Concepts</h1>
                        <p>The major purpose of C++ programming is to introduce the concept of object
                            orientation to the C programming language.</p>
                        <p>Object Oriented Programming is a paradigm that provides many concepts such as
                            <strong>inheritance, data binding, polymorphism etc.</strong>
                        </p>
                        <p>The programming paradigm where everything is represented as an object is known as
                            truly object-oriented programming language. <strong>Smalltalk</strong> is
                            considered as the first truly object-oriented programming language.</p>
                        <hr />
                        <h2 class="h2">OOPs (Object Oriented Programming System)</h2>
                        <p><strong>Object</strong> means a real word entity such as pen, chair, table etc.
                            <strong>Object-Oriented Programming</strong> is a methodology or paradigm to
                            design a program using classes and objects. It simplifies the software
                            development and maintenance by providing some concepts:
                        </p>
                        <img src="https://static.javatpoint.com/cpp/images/oops-concept1.png" alt="Cpp Oops concept 1"
                            style="float:right;" />
                        <ul class="points">
                            <li>Object</li>
                            <li>Class</li>
                            <li>Inheritance</li>
                            <li>Polymorphism</li>
                            <li>Abstraction</li>
                            <li>Encapsulation</li>
                        </ul>
    
                        <h3 class="h3">Object</h3>
                        <p>Any entity that has state and behavior is known as an object. For example: chair,
                            pen, table, keyboard, bike etc. It can be physical and logical.</p>
                        <h3 class="h3">Class</h3>
                        <p><strong>Collection of objects</strong> is called class. It is a logical entity.
                        </p>
                        <h3 class="h3">Inheritance</h3>
                        <p><strong>When one object acquires all the properties and behaviours of parent
                                object</strong> i.e. known as inheritance. It provides code reusability. It
                            is used to achieve runtime polymorphism.</p>
                        <h3 class="h3">Polymorphism</h3>
                        <p>When <strong>one task is performed by different ways</strong> i.e. known as
                            polymorphism. For example: to convince the customer differently, to draw
                            something e.g. shape or rectangle etc.</p>
                        <p>In C++, we use Function overloading and Function overriding to achieve
                            polymorphism.</p>
                        <h3 class="h3">Abstraction</h3>
                        <p><strong>Hiding internal details and showing functionality</strong> is known as
                            abstraction. For example: phone call, we don't know the internal processing.</p>
                        <p>In C++, we use abstract class and interface to achieve abstraction.</p>
                        <h3 class="h3">Encapsulation</h3>
                        <p><strong>Binding (or wrapping) code and data together into a single unit is known
                                as encapsulation.</strong> For example: capsule, it is wrapped with
                            different medicines.</p>
                        <hr />
                        <h2 class="h2">Advantage of OOPs over Procedure-oriented programming language</h2>
                        <ol class="points">
                            <li>OOPs makes development and maintenance easier where as in Procedure-oriented
                                programming language it is not easy to manage if code grows as project size
                                grows.</li>
                            <li>OOPs provide data hiding whereas in Procedure-oriented programming language
                                a global data can be accessed from anywhere.</li>
                            <li>OOPs provide ability to simulate real-world event much more effectively. We
                                can provide the solution of real word problem if we are using the
                                Object-Oriented Programming language.</li>
                        </ol>
    
                        <hr />
    
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">C++ Object and Class</h1>
                        <p>Since C++ is an object-oriented language, program is designed using objects and
                            classes in C++.</p>
                        <hr />
                        <h2 class="h2">C++ Object</h2>
                        <p>In C++, Object is a real world entity, for example, chair, car, pen, mobile,
                            laptop etc.</p>
                        <p>In other words, object is an entity that has state and behavior. Here, state
                            means data and behavior means functionality.</p>
                        <p>Object is a runtime entity, it is created at runtime.</p>
                        <p>Object is an instance of a class. All the members of the class can be accessed
                            through object.</p>
                        <p>Let's see an example to create object of student class using s1 as the reference
                            variable.</p>
                        <div class="codeblock"><textarea name="code" class="Java">
    Student s1;  //creating an object of Student    
    </textarea></div>
                        <p>In this example, Student is the type and s1 is the reference variable that refers
                            to the instance of Student class.</p>
                        <hr />
    
                        <h2 class="h2">C++ Class</h2>
                        <p>In C++, object is a group of similar objects. It is a template from which objects
                            are created. It can have fields, methods, constructors etc.</p>
                        <p>Let's see an example of C++ class that has three fields only.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    class Student  
     {  
         public:
         int id;  //field or data member   
         float salary; //field or data member
         String name;//field or data member  
     }  
    </textarea></div>
                        <hr />
                        <h2 class="h2">C++ Object and Class Example</h2>
                        <p>Let's see an example of class that has two fields: id and name. It creates
                            instance of the class, initializes the object and prints the object value.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
    class Student {
       public:
          int id;//data member (also instance variable)    
          string name;//data member(also instance variable)    
    };
    int main() {
        Student s1; //creating an object of Student 
        s1.id = 201;  
        s1.name = "Sonoo Jaiswal"; 
        cout&lt;&lt;s1.id&lt;&lt;endl;
        cout&lt;&lt;s1.name&lt;&lt;endl;
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    201
    Sonoo Jaiswal
    </pre>
                        </div>
                        <hr />
                        <h2 class="h2">C++ Class Example: Initialize and Display data through method</h2>
                        <p>Let's see another example of C++ class where we are initializing and displaying
                            object through method.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
    class Student {
       public:
           int id;//data member (also instance variable)    
           string name;//data member(also instance variable)    
           void insert(int i, string n)  
            {  
                id = i;  
                name = n;  
            }  
           void display()  
            {  
                cout&lt;&lt;id&lt;&lt;"  "&lt;&lt;name&lt;&lt;endl;  
            }  
    };
    int main(void) {
        Student s1; //creating an object of Student 
        Student s2; //creating an object of Student
        s1.insert(201, "Sonoo");  
        s2.insert(202, "Nakul");  
        s1.display();  
        s2.display();
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    201  Sonoo
    202  Nakul
    </pre>
                        </div>
                        <hr />
                        <h2 class="h2">C++ Class Example: Store and Display Employee Information</h2>
                        <p>Let's see another example of C++ class where we are storing and displaying
                            employee information using method.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
    class Employee {
       public:
           int id;//data member (also instance variable)    
           string name;//data member(also instance variable)
           float salary;
           void insert(int i, string n, float s)  
            {  
                id = i;  
                name = n;  
                salary = s;
            }  
           void display()  
            {  
                cout&lt;&lt;id&lt;&lt;"  "&lt;&lt;name&lt;&lt;"  "&lt;&lt;salary&lt;&lt;endl;  
            }  
    };
    int main(void) {
        Employee e1; //creating an object of Employee 
        Employee e2; //creating an object of Employee
        e1.insert(201, "Sonoo",990000);  
        e2.insert(202, "Nakul", 29000);  
        e1.display();  
        e2.display();  
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    201  Sonoo  990000
    202  Nakul  29000
    </pre>
                        </div>
    
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">C++ Constructor</h1>
                        <p>In C++, constructor is a special method which is invoked automatically at the
                            time of object creation. It is used to initialize the data members of new object
                            generally. The constructor in C++ has the same name as class or structure.</p>
                        <p>There can be two types of constructors in C++.</p>
                        <ul class="points">
                            <li>Default constructor</li>
                            <li>Parameterized constructor</li>
                        </ul>
                        <hr />
                        <h2 class="h2">C++ Default Constructor</h2>
                        <p>A constructor which has no argument is known as default constructor. It is
                            invoked at the time of creating object.</p>
                        <p>Let's see the simple example of C++ default Constructor.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
    class Employee
     {
       public:
            Employee()  
            {  
                cout&lt;&lt;"Default Constructor Invoked"&lt;&lt;endl;  
            }  
    };
    int main(void) 
    {
        Employee e1; //creating an object of Employee 
        Employee e2; 
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    Default Constructor Invoked 
    Default Constructor Invoked
    </pre>
                        </div>
                        <hr />
    
    
                        <h2 class="h2">C++ Parameterized Constructor</h2>
                        <p>A constructor which has parameters is called parameterized constructor. It is
                            used to provide different values to distinct objects.</p>
                        <p>Let's see the simple example of C++ Parameterized Constructor.</p>
                        <div class="codeblock3">
                            <pre>
    #include &lt;iostream&gt;
    using namespace std;
    class Employee {
       public:
           int id;//data member (also instance variable)    
           string name;//data member(also instance variable)
           float salary;
           Employee(int i, string n, float s)  
            {  
                id = i;  
                name = n;  
                salary = s;
            }  
           void display()  
            {  
                cout&lt;&lt;id&lt;&lt;"  "&lt;&lt;name&lt;&lt;"  "&lt;&lt;salary&lt;&lt;endl;  
            }  
    };
    int main(void) {
        Employee e1 =Employee(101, "Sonoo", 890000); //creating an object of Employee 
        Employee e2=Employee(102, "Nakul", 59000); 
        e1.display();  
        e2.display();  
        return 0;
    }
    </textarea></div>
    <p>Output:</p>
    <div class="codeblock3"><pre>
    101  Sonoo  890000
    102  Nakul  59000
    </pre>
                        </div>
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">C++ Destructor</h1>
                        <p>A destructor works opposite to constructor; it destructs the objects of classes.
                            It can be defined only once in a class. Like constructors, it is invoked
                            automatically.</p>
                        <p>A destructor is defined like constructor. It must have same name as class. But it
                            is prefixed with a tilde sign (~).</p>
                        <h4 class="n">Note: C++ destructor cannot have parameters. Moreover, modifiers can't
                            be applied on destructors.</h4>
    
                        <h2 class="h2">C++ Constructor and Destructor Example</h2>
                        <p>Let's see an example of constructor and destructor in C++ which is called
                            automatically.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
    class Employee
     {
       public:
            Employee()  
            {  
                cout&lt;&lt;"Constructor Invoked"&lt;&lt;endl;  
            }  
            ~Employee()  
            {  
                cout&lt;&lt;"Destructor Invoked"&lt;&lt;endl;  
            }
    };
    int main(void) 
    {
        Employee e1; //creating an object of Employee 
        Employee e2; //creating an object of Employee
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    Constructor Invoked
    Constructor Invoked
    Destructor Invoked
    Destructor Invoked
    </pre>
                        </div>
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">C++ Friend function</h1>
                        <p>If a function is defined as a friend function in C++, then the protected and
                            private data of a class can be accessed using the function.</p>
                        <p>By using the keyword friend compiler knows the given function is a friend
                            function.</p>
                        <p>For accessing the data, the declaration of a friend function should be done
                            inside the body of a class starting with the keyword friend.</p>
                        <h2 class="h2">Declaration of friend function in C++</h2>
                        <div class="codeblock"><textarea name="code" class="cpp">
    class class_name  
    {  
        friend data_type function_name(argument/s);            // syntax of friend function.
    };  
    </textarea></div>
                        <p>In the above declaration, the friend function is preceded by the keyword friend.
                            The function can be defined anywhere in the program like a normal C++ function.
                            The function definition does not use either the keyword <strong>friend or scope
                                resolution operator</strong>.</p>
                        <p><strong>Characteristics of a Friend function:</strong></p>
                        <ul class="points">
                            <li>The function is not in the scope of the class to which it has been declared
                                as a friend.</li>
                            <li>It cannot be called using the object as it is not in the scope of that
                                class.</li>
                            <li>It can be invoked like a normal function without using the object.</li>
                            <li>It cannot access the member names directly and has to use an object name and
                                dot membership operator with the member name.</li>
                            <li>It can be declared either in the private or the public part.</li>
                        </ul>
                        <h2 class="h2">C++ friend function Example</h2>
                        <p>Let's see the simple example of C++ friend function used to print the length of a
                            box.</p>
                        <div class="codeblock"><textarea name="code" class="cpp">
    #include &lt;iostream&gt;  
    using namespace std;  
    class Box  
    {  
        private:  
            int length;  
        public:  
            Box(): length(0) { }  
            friend int printLength(Box); //friend function  
    };  
    int printLength(Box b)  
    {  
       b.length += 10;  
        return b.length;  
    }  
    int main()  
    {  
        Box b;  
        cout&lt;&lt;"Length of box: "&lt;&lt; printLength(b)&lt;&lt;endl;  
        return 0;  
    }  
    </textarea></div>
                        <p><strong>Output:</strong></p>
                        <div class="codeblock3">
                            <pre>
    Length of box: 10  
    </pre>
                        </div>
                        <p><strong>Let's see a simple example when the function is friendly to two
                                classes.</strong></p>
                        <div class="codeblock"><textarea name="code" class="cpp">
    #include &lt;iostream&gt;
    using namespace std;
    class B;          // forward declarartion.
    class A
    {
        int x;
        public:
        void setdata(int i)
        {
            x=i;
        }
        friend void min(A,B);         // friend function.
    };
    class B
    {
        int y;
        public:
        void setdata(int i)
        {
            y=i;
        }
        friend void min(A,B);                    // friend function
    };
    void min(A a,B b)
    {
        if(a.x&lt;=b.y)
        std::cout &lt;&lt; a.x &lt;&lt; std::endl;
        else
        std::cout &lt;&lt; b.y &lt;&lt; std::endl;
    }
       int main()
    {
       A a;
       B b;
       a.setdata(10);
       b.setdata(20);
       min(a,b);
        return 0;
     }
    </textarea></div>
                        <p><strong>Output:</strong></p>
                        <div class="codeblock3">
                            <pre>
    10
    </pre>
                        </div>
                        <p>In the above example, min() function is friendly to two classes, i.e., the min()
                            function can access the private members of both the classes A and B.</p>
                        <h3 class="h3">C++ Friend class</h3>
                        <p>A friend class can access both private and protected members of the class in
                            which it has been declared as friend.</p>
                        <p><strong>Let's see a simple example of a friend class.</strong></p>
                        <div class="codeblock"><textarea name="code" class="cpp">
    #include &lt;iostream&gt;
    
    using namespace std;
    
    class A
    {
        int x =5;
        friend class B;           // friend class.
    };
    class B
    {
      public:
        void display(A &a)
        {
            cout&lt;&lt;"value of x is : "&lt;&lt;a.x;
        }
    };
    int main()
    {
        A a;
        B b;
        b.display(a);
        return 0;
    }
    </textarea></div>
                        <p><strong>Output:</strong></p>
                        <div class="codeblock3">
                            <pre>
    value of x is : 5
    </pre>
                        </div>
                        <p>In the above example, class B is declared as a friend inside the class A.
                            Therefore, B is a friend of class A. Class B can access the private members of
                            class A.</p>
    
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">C++ Inheritance</h1>
                        <p>In C++, inheritance is a process in which one object acquires all the properties
                            and behaviors of its parent object automatically. In such way, you can reuse,
                            extend or modify the attributes and behaviors which are defined in other class.
                        </p>
                        <p>In C++, the class which inherits the members of another class is called derived
                            class and the class whose members are inherited is called base class. The
                            derived class is the specialized class for the base class.</p>
                        <hr />
                        <h2 class="h2">Advantage of C++ Inheritance</h2>
                        <p><strong>Code reusability:</strong> Now you can reuse the members of your parent
                            class. So, there is no need to define the member again. So less code is required
                            in the class.</p>
                        <h2 class="h2">Types Of Inheritance</h2>
                        <p><strong>C++ supports five types of inheritance:</strong></p>
                        <ul class="points">
                            <li>Single inheritance</li>
                            <li>Multiple inheritance</li>
                            <li>Hierarchical inheritance</li>
                            <li>Multilevel inheritance</li>
                            <li>Hybrid inheritance</li>
                        </ul>
                        <img src="https://static.javatpoint.com/cpp/images/cpp-inheritance.png" alt="C++ Inheritance" />
                        <h2 class="h2">Derived Classes</h2>
                        <p>A Derived class is defined as the class derived from the base class.</p>
                        <p>The Syntax of Derived class:</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    class derived_class_name :: visibility-mode base_class_name
    {
        // body of the derived class.
    }
    </textarea></div>
                        <p><strong>Where,</strong></p>
                        <p><strong>derived_class_name:</strong> It is the name of the derived class.</p>
                        <p><strong>visibility mode:</strong> The visibility mode specifies whether the
                            features of the base class are publicly inherited or privately inherited. It can
                            be public or private.</p>
                        <p><strong>base_class_name:</strong> It is the name of the base class.</p>
                        <ul class="points">
                            <li>When the base class is privately inherited by the derived class, public
                                members of the base class becomes the private members of the derived class.
                                Therefore, the public members of the base class are not accessible by the
                                objects of the derived class only by the member functions of the derived
                                class.</li>
                            <li>When the base class is publicly inherited by the derived class, public
                                members of the base class also become the public members of the derived
                                class. Therefore, the public members of the base class are accessible by the
                                objects of the derived class as well as by the member functions of the base
                                class.</li>
                        </ul>
                        <h3 class="h4">Note:</h3>
                        <ul class="points">
                            <li>In C++, the default mode of visibility is private. </li>
                            <li>The private members of the base class are never inherited.</li>
                        </ul>
                        <h2 class="h2">C++ Single Inheritance</h2>
                        <p><strong>Single inheritance</strong> is defined as the inheritance in which a
                            derived class is inherited from the only one base class.</p>
                        <img src="https://static.javatpoint.com/cpp/images/cpp-inheritance2.png" alt="C++ Inheritance" />
                        <p>Where 'A' is the base class, and 'B' is the derived class.</p>
                        <h2 class="h2">C++ Single Level Inheritance Example: Inheriting Fields</h2>
                        <p>When one class inherits another class, it is known as single level inheritance.
                            Let's see the example of single level inheritance which inherits the fields
                            only.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
     class Account {
       public:
       float salary = 60000; 
     };
       class Programmer: public Account {
       public:
       float bonus = 5000;  
       };     
    int main(void) {
         Programmer p1;
         cout&lt;&lt;"Salary: "&lt;&lt;p1.salary&lt;&lt;endl;  
         cout&lt;&lt;"Bonus: "&lt;&lt;p1.bonus&lt;&lt;endl;  
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    Salary: 60000
    Bonus: 5000
    </pre>
                        </div>
                        <p>In the above example, Employee is the <strong>base</strong> class and Programmer
                            is the <strong>derived</strong> class.</p>
                        <h2 class="h2">C++ Single Level Inheritance Example: Inheriting Methods</h2>
                        <p>Let's see another example of inheritance in C++ which inherits methods only.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
     class Animal {
       public:
     void eat() { 
        cout&lt;&lt;"Eating..."&lt;&lt;endl; 
     }  
       };
       class Dog: public Animal  
       {  
           public:
         void bark(){
        cout&lt;&lt;"Barking..."; 
         }  
       }; 
    int main(void) {
        Dog d1;
        d1.eat();
        d1.bark();
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    Eating...
    Barking...
    </pre>
                        </div>
                        <p>Let's see a simple example.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
    class A
    {
        int a = 4;
        int b = 5;
        public:
        int mul()
        {
            int c = a*b;
            return c;
        }   
    };
    
    class B : private A
    {
        public:
        void display()
        {
            int result = mul();
            std::cout &lt;&lt;"Multiplication of a and b is : "&lt;&lt;result&lt;&lt; std::endl;
        }
    };
    int main()
    {
       B b;
       b.display();
    
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    Multiplication of a and b is : 20
    </pre>
                        </div>
                        <p>In the above example, class A is privately inherited. Therefore, the mul()
                            function of class 'A' cannot be accessed by the object of class B. It can only
                            be accessed by the member function of class B.</p>
                        <h2 class="h2">How to make a Private Member Inheritable</h2>
                        <p>The private member is not inheritable. If we modify the visibility mode by making
                            it public, but this takes away the advantage of data hiding.</p>
                        <p>C++ introduces a third visibility modifier, i.e., <strong>protected</strong>. The
                            member which is declared as protected will be accessible to all the member
                            functions within the class as well as the class immediately derived from it.</p>
                        <p><strong>Visibility modes can be classified into three categories:</strong></p>
                        <img src="https://static.javatpoint.com/cpp/images/cpp-inheritance3.png" alt="C++ Inheritance" />
                        <ul class="points">
                            <li><strong>Public</strong>: When the member is declared as public, it is
                                accessible to all the functions of the program.</li>
                            <li><strong>Private</strong>: When the member is declared as private, it is
                                accessible within the class only.</li>
                            <li><strong>Protected</strong>: When the member is declared as protected, it is
                                accessible within its own class as well as the class immediately derived
                                from it.</li>
                        </ul>
                        <h2 class="h2">Visibility of Inherited Members</h2>
                        <table class="alt">
                            <tr>
                                <th rowspan="2">Base class visibility</th>
                                <th colspan="3">Derived class visibility</th>
                            </tr>
                            <tr>
                                <th>Public</th>
                                <th>Private</th>
                                <th>Protected</th>
                            </tr>
                            <tr>
                                <td>Private</td>
                                <td>Not Inherited</td>
                                <td>Not Inherited</td>
                                <td>Not Inherited</td>
                            </tr>
                            <tr>
                                <td>Protected</td>
                                <td>Protected</td>
                                <td>Private</td>
                                <td>Protected</td>
                            </tr>
                            <tr>
                                <td>Public</td>
                                <td>Public</td>
                                <td>Private</td>
                                <td>Protected</td>
                            </tr>
                        </table>
                        <h2 class="h2">C++ Multilevel Inheritance</h2>
                        <p><strong>Multilevel inheritance</strong> is a process of deriving a class from
                            another derived class.</p>
                        <img src="https://static.javatpoint.com/cpp/images/cpp-inheritance4.png" alt="C++ Inheritance" />
                        <h2 class="h2">C++ Multi Level Inheritance Example</h2>
                        <p>When one class inherits another class which is further inherited by another
                            class, it is known as multi level inheritance in C++. Inheritance is transitive
                            so the last derived class acquires all the members of all its base classes.</p>
                        <p>Let's see the example of multi level inheritance in C++.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
     class Animal {
       public:
     void eat() { 
        cout&lt;&lt;"Eating..."&lt;&lt;endl; 
     }  
       };
       class Dog: public Animal 
       {  
           public:
         void bark(){
        cout&lt;&lt;"Barking..."&lt;&lt;endl; 
         }  
       }; 
       class BabyDog: public Dog 
       {  
           public:
         void weep() {
        cout&lt;&lt;"Weeping..."; 
         }  
       }; 
    int main(void) {
        BabyDog d1;
        d1.eat();
        d1.bark();
         d1.weep();
         return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    Eating...
    Barking...
    Weeping...
    </pre>
                        </div>
                        <h2 class="h2">C++ Multiple Inheritance</h2>
                        <p><strong>Multiple inheritance</strong> is the process of deriving a new class that
                            inherits the attributes from two or more classes.</p>
                        <img src="https://static.javatpoint.com/cpp/images/cpp-inheritance5.png" alt="C++ Inheritance" />
                        <p><strong>Syntax of the Derived class:</strong></p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    class D : visibility B-1, visibility B-2, ?
    {
        // Body of the class;
    } 
    </textarea></div>
                        <p>Let's see a simple example of multiple inheritance.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
    class A
    {
        protected:
         int a;
        public:
        void get_a(int n)
        {
            a = n;
        }
    };
    
    class B
    {
        protected:
        int b;
        public:
        void get_b(int n)
        {
            b = n;
        }
    };
    class C : public A,public B
    {
       public:
        void display()
        {
            std::cout &lt;&lt; "The value of a is : " &lt;&lt;a&lt;&lt; std::endl;
            std::cout &lt;&lt; "The value of b is : " &lt;&lt;b&lt;&lt; std::endl;
            cout&lt;&lt;"Addition of a and b is : "&lt;&lt;a+b;
        }
    };
    int main()
    {
       C c;
       c.get_a(10);
       c.get_b(20);
       c.display();
    
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    The value of a is : 10
    The value of b is : 20
    Addition of a and b is : 30
    </pre>
                        </div>
                        <p>In the above example, class 'C' inherits two base classes 'A' and 'B' in a public
                            mode.</p>
                        <h2 class="h2">Ambiquity Resolution in Inheritance</h2>
                        <p>Ambiguity can be occurred in using the multiple inheritance when a function with
                            the same name occurs in more than one base class.</p>
                        <p>Let's understand this through an example:</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
    class A
    {
        public:
        void display()
        {
            std::cout &lt;&lt; "Class A" &lt;&lt; std::endl;
        }
    };
    class B
    {
        public:
        void display()
        {
            std::cout &lt;&lt; "Class B" &lt;&lt; std::endl;
        }
    };
    class C : public A, public B
    {
        void view()
        {
            display();
        }
    };
    int main()
    {
        C c;
        c.display();
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    error: reference to 'display' is ambiguous
            display();
    </pre>
                        </div>
                        <ul class="points">
                            <li>The above issue can be resolved by using the class resolution operator with
                                the function. In the above example, the derived class code can be rewritten
                                as:</li>
                        </ul>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    class C : public A, public B
    {
        void view()
        {
            A :: display();         // Calling the display() function of class A.
            B :: display();         // Calling the display() function of class B.
    
        }
    };
    </textarea></div>
                        <p>An ambiguity can also occur in single inheritance.</p>
                        <p>Consider the following situation:</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    class A
    {
       public:
    void display()
    {
       cout&lt;&lt;?Class A?;
    } 
    } ;
    class B
    { 
      public:
     void display()
    {
     cout&lt;&lt;?Class B?;
    }
    } ;
    </textarea></div>
                        <p>In the above case, the function of the derived class overrides the method of the
                            base class. Therefore, call to the display() function will simply call the
                            function defined in the derived class. If we want to invoke the base class
                            function, we can use the class resolution operator.</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    int main()
    {
        B b;
       b.display();               // Calling the display() function of B class.
       b.B :: display();       // Calling the display() function defined in B class.
    } 
    </textarea></div>
                        <h2 class="h2">C++ Hybrid Inheritance</h2>
                        <p>Hybrid inheritance is a combination of more than one type of inheritance.</p>
                        <img src="https://static.javatpoint.com/cpp/images/cpp-inheritance6.png" alt="C++ Inheritance" />
                        <p>Let's see a simple example:</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
    class A
    {
        protected:
        int a;
        public:
        void get_a()
        {
           std::cout &lt;&lt; "Enter the value of 'a' : " &lt;&lt; std::endl;
           cin&gt;&gt;a;
        }
    };
    
    class B : public A 
    {
        protected:
        int b;
        public:
        void get_b()
        {
            std::cout &lt;&lt; "Enter the value of 'b' : " &lt;&lt; std::endl;
           cin&gt;&gt;b;
        }
    };
    class C 
    {
        protected:
        int c;
        public:
        void get_c()
        {
            std::cout &lt;&lt; "Enter the value of c is : " &lt;&lt; std::endl;
            cin&gt;&gt;c;
        }
    };
    
    class D : public B, public C
    {
        protected:
        int d;
        public:
        void mul()
        {
             get_a();
             get_b();
             get_c();
             std::cout &lt;&lt; "Multiplication of a,b,c is : " &lt;&lt;a*b*c&lt;&lt; std::endl;
        }
    };
    int main()
    {
        D d;
        d.mul();
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    Enter the value of 'a' :
    10              
    Enter the value of 'b' :    
    20      
    Enter the value of c is :   
    30  
    Multiplication of a,b,c is : 6000
    </pre>
                        </div>
                        <h2 class="h2">C++ Hierarchical Inheritance</h2>
                        <p>Hierarchical inheritance is defined as the process of deriving more than one
                            class from a base class.</p>
                        <img src="https://static.javatpoint.com/cpp/images/cpp-inheritance7.png" alt="C++ Inheritance" />
                        <p><strong>Syntax of Hierarchical inheritance:</strong></p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    class A
    {
        // body of the class A.
    }  
    class B : public A 
    {
        // body of class B.
    }
    class C : public A
    {
        // body of class C.
    } 
    class D : public A
    {
        // body of class D.
    } 
    </textarea></div>
                        <p>Let's see a simple example:</p>
                        <div class="codeblock"><textarea name="code" class="Cpp">
    #include &lt;iostream&gt;
    using namespace std;
    class Shape                 // Declaration of base class.
    {
        public:
        int a;
        int b;
        void get_data(int n,int m)
        {
            a= n;
            b = m;
        }
    };
    class Rectangle : public Shape  // inheriting Shape class
    {
        public:
        int rect_area()
        {
            int result = a*b;
            return result;
        }
    };
    class Triangle : public Shape    // inheriting Shape class
    {
        public:
        int triangle_area()
        {
            float result = 0.5*a*b;
            return result;
        }
    };
    int main()
    {
        Rectangle r;
        Triangle t;
        int length,breadth,base,height;
        std::cout &lt;&lt; "Enter the length and breadth of a rectangle: " &lt;&lt; std::endl;
        cin&gt;&gt;length&gt;&gt;breadth;
        r.get_data(length,breadth);
        int m = r.rect_area();
        std::cout &lt;&lt; "Area of the rectangle is : " &lt;&lt;m&lt;&lt; std::endl;
        std::cout &lt;&lt; "Enter the base and height of the triangle: " &lt;&lt; std::endl;
        cin&gt;&gt;base&gt;&gt;height;
        t.get_data(base,height);
        float n = t.triangle_area();
        std::cout &lt;&lt;"Area of the triangle is : "  &lt;&lt; n&lt;&lt;std::endl;
        return 0;
    }
    </textarea></div>
                        <p>Output:</p>
                        <div class="codeblock3">
                            <pre>
    Enter the length and breadth of a rectangle:
    23  
    20  
    Area of the rectangle is : 460          
    Enter the base and height of the triangle:  
    2   
    5
    Area of the triangle is : 5 
    </pre>
                        </div>
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">C++ Polymorphism</h1>
                        <p>The term "Polymorphism" is the combination of "poly" + "morphs" which means many
                            forms. It is a greek word. In object-oriented programming, we use 3 main
                            concepts: inheritance, encapsulation, and polymorphism.</p>
                        <h2 class="h2">Real Life Example Of Polymorphism</h2>
                        <p>Let's consider a real-life example of polymorphism. A lady behaves like a teacher
                            in a classroom, mother or daughter in a home and customer in a market. Here, a
                            single person is behaving differently according to the situations.</p>
                        <p><strong>There are two types of polymorphism in C++:</strong></p>
                        <img src="https://static.javatpoint.com/cpp/images/cpp-polymorphism.png" alt="C++" />
                        <ul class="points">
                            <li><strong>Compile time polymorphism</strong>: The overloaded functions are
                                invoked by matching the type and number of arguments. This information is
                                available at the compile time and, therefore, compiler selects the
                                appropriate function at the compile time. It is achieved by function
                                overloading and operator overloading which is also known as static binding
                                or early binding. Now, let's consider the case where function name and
                                prototype is same.</li>
                        </ul>
                        <div class="codeblock"><textarea name="code" class="cpp">
       class A                                  //  base class declaration.
      {
           int a;
           public:
           void display()
           { 
                 cout&lt;&lt; "Class A ";
            }
      };
    class B : public A                       //  derived class declaration.
    {
        int b;
        public:
       void display()
      {
            cout&lt;&lt;"Class B";
      }
    };
    </textarea></div>
                        <p>In the above case, the prototype of display() function is the same in both the
                            <strong>base and derived class</strong>. Therefore, the static binding cannot be
                            applied. It would be great if the appropriate function is selected at the run
                            time. This is known as <strong>run time polymorphism</strong>.
                        </p>
                        <ul class="points">
                            <li><strong>Run time polymorphism</strong>: Run time polymorphism is achieved
                                when the object's method is invoked at the run time instead of compile time.
                                It is achieved by method overriding which is also known as dynamic binding
                                or late binding.</li>
                        </ul>
                        <h2 class="h2">Differences b/w compile time and run time polymorphism.</h2>
                        <table class="alt">
                            <tr>
                                <th>Compile time polymorphism</th>
                                <th>Run time polymorphism</th>
                            </tr>
                            <tr>
                                <td>The function to be invoked is known at the compile time.</td>
                                <td>The function to be invoked is known at the run time.</td>
                            </tr>
                            <tr>
                                <td>It is also known as overloading, early binding and static binding.</td>
                                <td>It is also known as overriding, Dynamic binding and late binding.</td>
                            </tr>
                            <tr>
                                <td>Overloading is a compile time polymorphism where more than one method is
                                    having the same name but with the different number of parameters or the
                                    type of the parameters.</td>
                                <td>Overriding is a run time polymorphism where more than one method is
                                    having the same name, number of parameters and the type of the
                                    parameters.</td>
                            </tr>
                            <tr>
                                <td>It is achieved by function overloading and operator overloading.</td>
                                <td>It is achieved by virtual functions and pointers.</td>
                            </tr>
                            <tr>
                                <td>It provides fast execution as it is known at the compile time.</td>
                                <td>It provides slow execution as it is known at the run time.</td>
                            </tr>
                            <tr>
                                <td>It is less flexible as mainly all the things execute at the compile
                                    time.</td>
                                <td>It is more flexible as all the things execute at the run time.</td>
                            </tr>
                        </table>
                        <h2 class="h2">C++ Runtime Polymorphism Example</h2>
                        <p>Let's see a simple example of run time polymorphism in C++.</p>
                        <p>// an example without the virtual keyword.</p>
                        <div class="codeblock"><textarea name="code" class="cpp">
    #include &lt;iostream&gt;  
    using namespace std;  
    class Animal {  
        public:  
    void eat(){    
    cout&lt;&lt;"Eating...";    
        }      
    };   
    class Dog: public Animal    
    {    
     public:  
     void eat()    
        {           cout&lt;&lt;"Eating bread...";    
        }    
    };  
    int main(void) {  
       Dog d = Dog();    
       d.eat();  
       return 0;  
    }  
    </textarea></div>
                        <p><strong>Output:</strong></p>
                        <div class="codeblock3">
                            <pre>
    Eating bread...
    </pre>
                        </div>
                        <h2 class="h2">C++ Run time Polymorphism Example: By using two derived class</h2>
                        <p>Let's see another example of run time polymorphism in C++ where we are having two
                            derived classes.</p>
                        <p>// an example with virtual keyword.</p>
                        <div class="codeblock"><textarea name="code" class="cpp">
    #include &lt;iostream&gt;  
    using namespace std;  
    class Shape {                                        //  base class
        public:  
    virtual void draw(){                             // virtual function
    cout&lt;&lt;"drawing..."&lt;&lt;endl;    
        }      
    };   
    class Rectangle: public Shape                  //  inheriting Shape class.
    {    
     public:  
     void draw()    
       {    
           cout&lt;&lt;"drawing rectangle..."&lt;&lt;endl;    
        }    
    };  
    class Circle: public Shape                        //  inheriting Shape class.
    
    {    
     public:  
     void draw()    
       {    
          cout&lt;&lt;"drawing circle..."&lt;&lt;endl;    
       }    
    };  
    int main(void) {  
        Shape *s;                               //  base class pointer.
        Shape sh;                               // base class object.
           Rectangle rec;  
            Circle cir;  
          s=&sh;  
         s-&gt;draw();   
            s=&rec;  
         s-&gt;draw();    
        s=?  
        s-&gt;draw();   
    }  
    </textarea></div>
                        <p><strong>Output:</strong></p>
                        <div class="codeblock3">
                            <pre>
    drawing...
    drawing rectangle...
    drawing circle...
    </pre>
                        </div>
                        <h2 class="h2">Runtime Polymorphism with Data Members</h2>
                        <p>Runtime Polymorphism can be achieved by data members in C++. Let's see an example
                            where we are accessing the field by reference variable which refers to the
                            instance of derived class.</p>
                        <div class="codeblock"><textarea name="code" class="cpp">
    #include &lt;iostream&gt;  
    using namespace std;  
    class Animal {                                          //  base class declaration.
        public:  
        string color = "Black";    
    };   
    class Dog: public Animal                       // inheriting Animal class.
    {    
     public:  
        string color = "Grey";    
    };  
    int main(void) {  
         Animal d= Dog();    
        cout&lt;&lt;d.color;   
    }  
    </textarea></div>
                        <p><strong>Output:</strong></p>
                        <div class="codeblock3">
                            <pre>
    Black
    </pre>
                        </div>
                        <!-- link -->
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">Data Abstraction in C++</h1>
                        <ul class="points">
                            <li>Data Abstraction is a process of providing only the essential details to the
                                outside world and hiding the internal details, i.e., representing only the
                                essential details in the program.</li>
                            <li>Data Abstraction is a programming technique that depends on the seperation
                                of the interface and implementation details of the program.</li>
                            <li>Let's take a real life example of AC, which can be turned ON or OFF, change
                                the temperature, change the mode, and other external components such as fan,
                                swing. But, we don't know the internal details of the AC, i.e., how it works
                                internally. Thus, we can say that AC seperates the implementation details
                                from the external interface.</li>
                            <li>C++ provides a great level of abstraction. For example, pow() function is
                                used to calculate the power of a number without knowing the algorithm the
                                function follows.</li>
                        </ul>
                        <p>In C++ program if we implement class with private and public members then it is
                            an example of data abstraction.</p>
                        <p><strong>Data Abstraction can be achieved in two ways:</strong></p>
                        <ul class="points">
                            <li>Abstraction using classes</li>
                            <li>Abstraction in header files.</li>
                        </ul>
                        <img src="https://static.javatpoint.com/cpp/images/cpp-data-abstraction.png"
                            alt="Data Abstraction in C++" />
                        <p><strong>Abstraction using classes:</strong> An abstraction can be achieved using
                            classes. A class is used to group all the data members and member functions into
                            a single unit by using the access specifiers. A class has the responsibility to
                            determine which data member is to be visible outside and which is not.</p>
                        <p><strong>Abstraction in header files:</strong> An another type of abstraction is
                            header file. For example, pow() function available is used to calculate the
                            power of a number without actually knowing which algorithm function uses to
                            calculate the power. Thus, we can say that header files hides all the
                            implementation details from the user.</p>
                        <p><strong>Access Specifiers Implement Abstraction:</strong></p>
                        <ul class="points">
                            <li><strong>Public specifier:</strong> When the members are declared as public,
                                members can be accessed anywhere from the program.</li>
                            <li><strong>Private specifier:</strong> When the members are declared as
                                private, members can only be accessed only by the member functions of the
                                class.</li>
                        </ul>
                        <p>Let's see a simple example of abstraction in header files.</p>
                        <p><strong>// program to calculate the power of a number.</strong></p>
                        <div class="codeblock"><textarea name="code" class="cpp">
    #include &lt;iostream&gt;
    #include&lt;math.h&gt;
    using namespace std;
    int main()
    {  
     int n = 4;
       int power = 3;
       int result = pow(n,power);         // pow(n,power) is the  power function
       std::cout &lt;&lt; "Cube of n is : " &lt;&lt;result&lt;&lt; std::endl;
       return 0;
    }
    </textarea></div>
                        <p><strong>Output:</strong></p>
                        <div class="codeblock3">
                            <pre>
    Cube of n is : 64
    </pre>
                        </div>
                        <p>In the above example, pow() function is used to calculate 4 raised to the power
                            3. The pow() function is present in the math.h header file in which all the
                            implementation details of the pow() function is hidden.</p>
                        <p><strong>Let's see a simple example of data abstraction using classes.</strong>
                        </p>
                        <div class="codeblock"><textarea name="code" class="cpp">
    #include &lt;iostream&gt;  
    using namespace std;  
     class Sum  
    {  
    private: int x, y, z; // private variables
    public:  
    void add()  
    {  
    cout&lt;&lt;"Enter two numbers: ";  
    cin&gt;&gt;x&gt;&gt;y;  
    z= x+y;  
    cout&lt;&lt;"Sum of two number is: "&lt;&lt;z&lt;&lt;endl;  
    }  
    };  
    int main()  
    {  
    Sum sm;  
    sm.add();  
    return 0;  
    }  
    </textarea></div>
                        <p><strong>Output:</strong></p>
                        <div class="codeblock3">
                            <pre>
    Enter two numbers:
    3
    6
    Sum of two number is: 9
    </pre>
                        </div>
                        <p>In the above example, abstraction is achieved using classes. A class 'Sum'
                            contains the private members x, y and z are only accessible by the member
                            functions of the class.</p>
                        <h2 class="h2">Advantages Of Abstraction:</h2>
                        <ul class="points">
                            <li>Implementation details of the class are protected from the inadvertent user
                                level errors.</li>
                            <li>A programmer does not need to write the low level code.</li>
                            <li>Data Abstraction avoids the code duplication, i.e., programmer does not have
                                to undergo the same tasks every time to perform the similar operation.</li>
                            <li>The main aim of the data abstraction is to reuse the code and the proper
                                partitioning of the code across the classes.</li>
                            <li>Internal implementation can be changed without affecting the user level
                                code.</li>
                        </ul>
                        <!-- link -->
                        <br /><br />
    
                        <div id="bottomnextup">
                            <a class="next" href="/">next &rarr;</a>
                            <a class="next" href="/c++page3">prev &larr;</a>
                        </div>
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>



</body>


</html>

{% endblock %}