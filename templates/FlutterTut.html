{% extends "layout.html" %} {% block body %}

<html>

<head>
    <title>Flutter Tutorial | Flutter Tutorial - Greplearn</title>
    <link href="{{url_for('static', filename='ContentAsset/new.css')}}" rel="stylesheet">
</head>


<body>
    <br>
    <br>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
                        <br>
                        <br>
    
                        <h1 class="h1">Flutter Tutorial</h1>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-logo.png" class="imageright"
                            alt="Flutter Tutorial" />
                        <p>Our Flutter Tutorial provides basic and advanced concepts of the Flutter
                            framework. Flutter is a UI toolkit for building fast, beautiful, natively
                            compiled applications for mobile, web, and desktop with one programing language
                            and single codebase. It is free and open-source. Initially, it was developed
                            from <strong>Google</strong> and now manages by an <strong>ECMA
                                standard</strong>. Flutter apps use Dart programming language for creating
                            an app.</p>
                        <p>The first version of Flutter was announced in the year <strong>2015</strong> at
                            the Dart Developer Summit. It was initially known as codename
                            <strong>Sky</strong> and can run on the Android OS. On <strong>December 4,
                                2018</strong>, the first stable version of the Flutter framework was
                            released, denoting Flutter 1.0. The current stable release of the framework is
                            Flutter v1.9.1+hotfix.6 on October 24, 2019.
                        </p>
                        <h2 class="h2">What is Flutter?</h2>
                        <p>In general, creating a mobile application is a very complex and challenging task.
                            There are many frameworks available, which provide excellent features to develop
                            mobile applications. For developing mobile apps, Android provides a native
                            framework based on Java and Kotlin language, while iOS provides a framework
                            based on Objective-C/Swift language. Thus, we need two different languages and
                            frameworks to develop applications for both OS. Today, to overcome form this
                            complexity, there are several frameworks have introduced that support both OS
                            along with desktop apps. These types of the framework are known as
                            <strong>cross-platform</strong> development tools.
                        </p>
                        <p>The cross-platform development framework has the ability to write one code and
                            can deploy on the various platform (Android, iOS, and Desktop). It saves a lot
                            of time and development efforts of developers. There are several tools available
                            for cross-platform development, including web-based tools, such as Ionic from
                            Drifty Co. in 2013, Phonegap from Adobe, Xamarin from Microsoft, and React
                            Native form Facebook. Each of these frameworks has varying degrees of success in
                            the mobile industry. In recent, a new framework has introduced in the
                            cross-platform development family named <strong>Flutter</strong> developed from
                            Google.</p>
                        <p>Flutter is a UI toolkit for creating fast, beautiful, natively compiled
                            applications for mobile, web, and desktop with one programing language and
                            single codebase. It is free and open-source. It was initially developed from
                            <strong>Google</strong> and now manages by an <strong>ECMA</strong> standard.
                            Flutter apps use Dart programming language for creating an app. The <strong>dart
                                programming</strong> shares several same features as other programming
                            languages, such as Kotlin and Swift, and can be trans-compiled into JavaScript
                            code.
                        </p>
                        <p>Flutter is mainly optimized for 2D mobile apps that can run on both Android and
                            iOS platforms. We can also use it to build full-featured apps, including camera,
                            storage, geolocation, network, third-party SDKs, and more.</p>
                        <h2 class="h2">What makes Flutter unique?</h2>
                        <p>Flutter is different from other frameworks because it neither uses
                            <strong>WebView</strong> nor the <strong>OEM</strong> widgets that shipped with
                            the device. Instead, it uses its own high-performance rendering engine to draw
                            widgets. It also implements most of its systems such as animation, gesture, and
                            widgets in Dart programing language that allows developers to read, change,
                            replace, or remove things easily. It gives excellent control to the developers
                            over the system.
                        </p>
                        <h2 class="h2">Features of Flutter</h2>
                        <p>Flutter gives easy and simple methods to start building beautiful mobile and
                            desktop apps with a rich set of material design and widgets. Here, we are going
                            to discuss its main features for developing the mobile framework.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-features.png"
                            alt="Flutter Tutorial" />
                        <p><strong>Open-Source:</strong> Flutter is a free and open-source framework for
                            developing mobile applications.</p>
                        <p><strong>Cross-platform:</strong> This feature allows Flutter to write the code
                            once, maintain, and can run on different platforms. It saves the time, effort,
                            and money of the developers.</p>
                        <p><strong>Hot Reload:</strong> Whenever the developer makes changes in the code,
                            then these changes can be seen instantaneously with Hot Reload. It means the
                            changes immediately visible in the app itself. It is a very handy feature, which
                            allows the developer to fix the bugs instantly. </p>
                        <p><strong>Accessible Native Features and SDKs:</strong> This feature allows the app
                            development process easy and delightful through Flutter's native code,
                            third-party integration, and platform APIs. Thus, we can easily access the SDKs
                            on both platforms.</p>
                        <p><strong>Minimal code:</strong> Flutter app is developed by Dart programming
                            language, which uses JIT and AOT compilation to improve the overall start-up
                            time, functioning and accelerates the performance. JIT enhances the development
                            system and refreshes the UI without putting extra effort into building a new
                            one.</p>
                        <p><strong>Widgets:</strong> The Flutter framework offers widgets, which are capable
                            of developing customizable specific designs. Most importantly, Flutter has two
                            sets of widgets: Material Design and Cupertino widgets that help to provide a
                            glitch-free experience on all platforms.</p>
                        <h2 class="h2">Advantage of Flutter</h2>
                        <p>Flutter fulfills the custom needs and requirements for developing mobile
                            applications. It also offers many advantages, which are listed below.</p>
                        <ul class="points">
                            <li>It makes the app development process extremely fast because of the
                                hot-reload feature. This feature allows us to change or update the code are
                                reflected as soon as the alterations are made.</li>
                            <li>It provides the smoother and seamless scrolling experiences of using the app
                                without much hangs or cuts, which makes running applications faster in
                                comparison to other mobile app development frameworks.</li>
                            <li>Flutter reduces the time and efforts of testing. As we know, flutter apps
                                are cross-platform so that testers do not always need to run the same set of
                                tests on different platforms for the same app.</li>
                            <li>It has an excellent user interface because it uses a design-centric widget,
                                high-development tools, advanced APIs, and many more features.</li>
                            <li>It is similar to a reactive framework where the developers do not need to
                                update the UI content manually.</li>
                            <li>It is suitable for MVP (Minimum Viable Product) apps because of its speedy
                                development process and cross-platform nature.</li>
                        </ul>
                        <h2 class="h2">Disadvantages of Flutter</h2>
                        <p>We have seen earlier that the Flutter has many advantages, but it also contains
                            some disadvantages, which are given below.</p>
                        <ul class="points">
                            <li>The Flutter is a comparatively new language that needs continuous
                                integration support through the maintenance of scripts.</li>
                            <li>It provides very limited access to SDK libraries. It means a developer does
                                not have a lot of functionalities to create a mobile application. Such types
                                of functionalities need to be developed by the Flutter developer themselves.
                            </li>
                            <li>The Flutter apps do not support the browser. It only supports Android and
                                iOS platforms.</li>
                            <li>It uses Dart programming for coding, so a developer needs to learn new
                                technologies. However, it is easy to learn for developers.</li>
                        </ul>
                        <h2 class="h2">History of Flutter</h2>
                        <p>Flutter is a free and open-source UI software development kit introduced by
                            Google. It is used to build applications for Android, iOS, Windows, and the web.
                            The first version of Flutter was announced in the year <strong>2015</strong> at
                            the <strong>Dart Developer Summit</strong>. It was initially known as codename
                            <strong>"Sky"</strong> and can run on the Android OS. After the announcement of
                            Flutter, the first Flutter Alpha version (v-0.06) was released in May
                            <strong>2017</strong>.
                        </p>
                        <p>Later, during the keynote of Google Developer days in Shanghai, Google launched
                            the second preview of Flutter in <strong>September 2018</strong> that was the
                            last big release before Flutter 1.0 version. On <strong>December 4,
                                2018</strong>, the first stable version of the Flutter framework was
                            released at the Flutter Live event, denoting Flutter 1.0. The current stable
                            release of the framework is Flutter v1.9.1+hotfix.6 on October 24, 2019.</p>
                        <h2 class="h2">Prerequisite</h2>
                        <p>Before learning Flutter in-depth, you must have a sound understanding of Dart
                            programming, Android Studio, and web scripting languages such as HTML,
                            JavaScript, and CSS.</p>
                        <h2 class="h2">Audience</h2>
                        <p>We have developed this tutorial for beginners and professionals both who want to
                            build a career around Flutter or seamlessly learn the precepts of Flutter. There
                            are a lot of topics available that will help you to learn Flutter technology
                            easily.</p>
                        <h2 class="h2">Problems</h2>
                        <p>We assure you that you will not find any problem with our Flutter tutorial. But,
                            if you find any mistake, you can post it in our comment section.</p>
    
                        <hr />
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">Flutter First Application</h1>
                        <p>In this section, we are going to learn how to create a simple application in
                            Android Studio to understand the basics of the Flutter application. To create
                            Flutter application, do the following steps:</p>
                        <p><strong>Step 1:</strong> Open the Android Studio.</p>
                        <p><strong>Step 2:</strong> Create the Flutter project. To create a project, go to
                            File-> New->New Flutter Project. The following screen helps to understand it
                            more clearly.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-first-application.png"
                            alt="Flutter First Application" />
                        <p><strong>Step 3:</strong> In the next wizard, you need to choose the Flutter
                            Application. For this, select Flutter Application-> click Next, as shown in the
                            below screen.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-first-application2.png"
                            alt="Flutter First Application" />
                        <p><strong>Step 4:</strong> Next, configure the application details as shown in the
                            below screen and click on the Next button.</p>
                        <p><strong>Project Name:</strong> Write your Application Name.</p>
                        <p><strong>Flutter SDK Path:</strong> &lt;path_to_flutter_sdk&gt;</p>
                        <p><strong>Project Location:</strong> &lt;path_to_project_folder&gt;</p>
                        <p><strong>Descriptions:</strong> &lt;A new Flutter hello world application&gt;.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-first-application3.png"
                            alt="Flutter First Application" />
                        <p><strong>Step 5:</strong> In the next wizard, you need to set the company domain
                            name and click the Finish button. </p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-first-application4.png"
                            alt="Flutter First Application" />
                        <p>After clicking the Finish button, it will take some time to create a project.
                            When the project is created, you will get a fully working Flutter application
                            with minimal functionality.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-first-application5.png"
                            alt="Flutter First Application" />
                        <p><strong>Step 6:</strong> Now, let us check the structure of the Flutter project
                            application and its purpose. In the below image, you can see the various folders
                            and components of the Flutter application structure, which are going to discuss
                            here.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-first-application6.png"
                            alt="Flutter First Application" />
                        <p><strong>.idea:</strong> This folder is at the very top of the project structure,
                            which holds the configuration for Android Studio. It doesn't matter because we
                            are not going to work with Android Studio so that the content of this folder can
                            be ignored.</p>
                        <p><strong>.android:</strong> This folder holds a complete Android project and used
                            when you build the Flutter application for Android. When the Flutter code is
                            compiled into the native code, it will get injected into this Android project,
                            so that the result is a native Android application. <strong>For
                                Example:</strong> When you are using the Android emulator, this Android
                            project is used to build the Android app, which further deployed to the Android
                            Virtual Device.</p>
                        <p><strong>.ios:</strong> This folder holds a complete Mac project and used when you
                            build the Flutter application for iOS. It is similar to the android folder that
                            is used when developing an app for Android. When the Flutter code is compiled
                            into the native code, it will get injected into this iOS project, so that the
                            result is a native iOS application. Building a Flutter application for iOS is
                            only possible when you are working on macOS.</p>
                        <p><strong>.lib:</strong> It is an essential folder, which stands for the library.
                            It is a folder where we will do our 99 percent of project work. Inside the lib
                            folder, we will find the Dart files which contain the code of our Flutter
                            application. By default, this folder contains the file
                            <strong>main.dart</strong>, which is the entry file of the Flutter application.
                        </p>
                        <p><strong>.test:</strong> This folder contains a Dart code, which is written for
                            the Flutter application to perform the automated test when building the app. It
                            won't be too important for us here.</p>
                        <p>We can also have some default files in the Flutter application. In 99.99 percent
                            of cases, we don't touch these files manually. These files are:</p>
                        <p><strong>.gitignore:</strong> It is a text file containing a list of files, file
                            extensions, and folders that tells Git which files should be ignored in a
                            project. Git is a version-control file for tracking changes in source code
                            during software development Git.</p>
                        <p><strong>.metadata:</strong> It is an auto-generated file by the flutter tools,
                            which is used to track the properties of the Flutter project. This file performs
                            the internal tasks, so you do not need to edit the content manually at any time.
                        </p>
                        <p><strong>.packages:</strong> It is an auto-generated file by the Flutter SDK,
                            which is used to contain a list of dependencies for your Flutter project.</p>
                        <p><strong>flutter_demoapp.iml:</strong> It is always named according to the Flutter
                            project's name that contains additional settings of the project. This file
                            performs the internal tasks, which is managed by the Flutter SDK, so you do not
                            need to edit the content manually at any time.</p>
                        <p><strong>pubspec.yaml:</strong> It is the project's configuration file that will
                            use a lot during working with the Flutter project. It allows you how your
                            application works. This file contains:</p>
                        <ul class="points">
                            <li>Project general settings such as name, description, and version of the
                                project.</li>
                            <li>Project dependencies.</li>
                            <li>Project assets (e.g., images).</li>
                        </ul>
                        <p><strong>pubspec.lock:</strong> It is an auto-generated file based on the
                            <strong>.yaml</strong> file. It holds more detail setup about all dependencies.
                        </p>
                        <p><strong>README.md:</strong> It is an auto-generated file that holds information
                            about the project. We can edit this file if we want to share information with
                            the developers.</p>
                        <p><strong>Step 7:</strong> Open the <strong>main.dart</strong> file and replace the
                            code with the following code snippets.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    import 'package:flutter/material.dart';
    
    void main() => runApp(MyApp());
    
    class MyApp extends StatelessWidget {
      // This widget is the root of your application.
      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          title: 'Hello World Flutter Application',
          theme: ThemeData(
            // This is the theme of your application.
            primarySwatch: Colors.blue,
          ),
          home: MyHomePage(title: 'Home page'),
        );
      }
    }
    class MyHomePage extends StatelessWidget {
      MyHomePage({Key key, this.title}) : super(key: key);
      // This widget is the home page of your application.
      final String title;
    
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(
            title: Text(this.title),
          ),
          body: Center(
            child: Text('Hello World'),
          ),
        );
      }
    }
    </textarea></div>
                        <p><strong>Step 8:</strong> Let us understand the above code snippet line by line.
                        </p>
                        <ul class="points">
                            <li>To start Flutter programming, you need first to import the Flutter package.
                                Here, we have imported a <strong>Material package</strong>. This package
                                allows you to create user interface according to the Material design
                                guidelines specified by Android.</li>
                            <li>The second line is an entry point of the Flutter applications similar to the
                                main method in other programming languages. It calls the
                                <strong>runApp</strong> function and pass it an object of
                                <strong>MyApp</strong> The primary purpose of this function is to attach the
                                given widget to the screen.
                            </li>
                            <li>Line 5 to 18 is a widget used for creating UI in the Flutter framework.
                                Here, the <strong>StatelessWidget</strong> does not maintain any state of
                                the widget. MyApp extends StatelessWidget that overrides its
                                <strong>build</strong> The build method is used for creating a part of the
                                UI of the application. In this block, the build method uses MaterialApp, a
                                widget to create the root level UI of the application and contains three
                                properties - title, theme, and home.
                                <ol class="points">
                                    <li><strong>Title:</strong> It is the title of the Flutter application.
                                    </li>
                                    <li><strong>Theme:</strong> It is the theme of the widget. By default,
                                        it set the blue as the overall color of the application.</li>
                                    <li><strong>Home:</strong> It is the inner UI of the application, which
                                        sets another widget (MyHomePage) for the application.</li>
                                </ol>
                            </li>
                            <li>Line 19 to 35, the <strong>MyHomePage</strong> is similar to MyApp, except
                                it will return the <strong>Scaffold</strong> Scaffold widget is a top-level
                                widget after the MaterialApp widget for creating the user interface. This
                                widget contains two properties <strong>appBar</strong> and
                                <strong>body</strong>. The appBar shows the header of the app, and body
                                property shows the actual content of the application. Here,
                                <strong>AppBar</strong> render the header of the application,
                                <strong>Center</strong> widget is used to center the child widget, and
                                <strong>Text</strong> is the final widget used to show the text content and
                                displays in the center of the screen.
                            </li>
                        </ul>
                        <p><strong>Step 9:</strong> Now, run the application. To do this, go to Run->Run
                            main.dart, as shown in the below screen.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-first-application7.png"
                            alt="Flutter First Application" />
                        <p><strong>Step 10:</strong> Finally, you will get the output as below screen.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-first-application8.png"
                            alt="Flutter First Application" />
    
                        <hr />
    
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">Flutter Architecture</h1>
                        <p>In this section, we are going to discuss the architecture of the Flutter
                            framework. The Flutter architecture mainly comprises of four components.</p>
                        <ol class="points">
                            <li>Flutter Engine</li>
                            <li>Foundation Library</li>
                            <li>Widgets</li>
                            <li>Design Specific Widgets</li>
                        </ol>
                        <h3 class="h3">Flutter Engine</h3>
                        <p>It is a portable runtime for high-quality mobile apps and primarily based on the
                            C++ language. It implements Flutter core libraries that include animation and
                            graphics, file and network I/O, plugin architecture, accessibility support, and
                            a dart runtime for developing, compiling, and running Flutter applications. It
                            takes Google's open-source graphics library, <strong>Skia</strong>, to render
                            low-level graphics.</p>
                        <h3 class="h3">Foundation Library</h3>
                        <p>It contains all the required packages for the basic building blocks of writing a
                            Flutter application. These libraries are written in Dart language.</p>
                        <h3 class="h3">Widgets</h3>
                        <p>In Flutter, everything is a widget, which is the core concept of this framework.
                            Widget in the Flutter is basically a user interface component that affects and
                            controls the view and interface of the app. It represents an immutable
                            description of part of the user interface and includes graphics, text, shapes,
                            and animations that are created using widgets. The widgets are similar to the
                            React components.</p>
                        <p>In Flutter, the application is itself a widget that contains many sub widgets. It
                            means the app is the top-level widget, and its UI is build using one or more
                            children widgets, which again includes sub child widgets. This feature helps you
                            to create a complex user interface very easily.</p>
                        <p>We can understand it from the hello world example created in the previous
                            section. Here, we are going to explain the example with the following diagram.
                        </p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-architecture.png"
                            alt="Flutter Architecture" />
                        <p>In the above example, we can see that all the components are widgets that contain
                            child widgets. Thus, the Flutter application is itself a widget.</p>
                        <h3 class="h3">Design Specific Widgets</h3>
                        <p>The Flutter framework has two sets of widgets that conform to specific design
                            languages. These are Material Design for Android application and Cupertino Style
                            for IOS application.</p>
                        <h3 class="h3">Gestures</h3>
                        <p>It is a widget that provides interaction (how to listen for and respond to) in
                            Flutter using GestureDetector. <strong>GestureDector</strong> is an invisible
                            widget, which includes tapping, dragging, and scaling interaction of its child
                            widget. We can also use other interactive features into the existing widgets by
                            composing with the GestureDetector widget.</p>
                        <h3 class="h3">State Management</h3>
                        <p>Flutter widget maintains its state by using a special widget, StatefulWidget. It
                            is always auto re-rendered whenever its internal state is changed. The
                            re-rendering is optimized by calculating the distance between old and new widget
                            UI and render only necessary things that are changes.</p>
                        <h3 class="h3">Layers</h3>
                        <p>Layers are an important concept of the Flutter framework, which are grouped into
                            multiple categories in terms of complexity and arranged in the top-down
                            approach. The topmost layer is the UI of the application, which is specific to
                            the Android and iOS platforms. The second topmost layer contains all the Flutter
                            native widgets. The next layer is the rendering layer, which renders everything
                            in the Flutter app. Then, the layers go down to Gestures, foundation library,
                            engine, and finally, core platform-specific code. The following diagram
                            specifies the layers in Flutter app development.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-architecture2.png"
                            alt="Flutter Architecture" />
    
                        <hr />
    
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">Flutter Widgets</h1>
                        <p>In this section, we are going to learn the concept of a widget, how to create it,
                            and their different types available in the Flutter framework. We have learned
                            earlier that everything in Flutter is a widget.</p>
                        <p>If you are familiar with React or Vue.js, then it is easy to understand the
                            Flutter.</p>
                        <p>Whenever you are going to code for building anything in Flutter, it will be
                            inside a widget. The central purpose is to build the app out of widgets. It
                            describes how your app view should look like with their current configuration
                            and state. When you made any alteration in the code, the widget rebuilds its
                            description by calculating the difference of previous and current widget to
                            determine the minimal changes for rendering in UI of the app.</p>
                        <p>Widgets are nested with each other to build the app. It means the root of your
                            app is itself a widget, and all the way down is a widget also. For example, a
                            widget can display something, can define design, can handle interaction, etc.
                        </p>
                        <p>The below image is a simple visual representation of the widget tree.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-widgets.png"
                            alt="Flutter Widgets" />
                        <p>We can create the Flutter widget like this:</p>
                        <div class="codeblock"><textarea name="code" class="java">
    Class ImageWidget extends StatelessWidget {
             // Class Stuff
    }
    </textarea></div>
                        <p class="pq"><strong>Hello World Example</strong></p>
                        <div class="codeblock"><textarea name="code" class="java">
    import 'package:flutter/material.dart';
    
    class MyHomePage extends StatelessWidget {  
      MyHomePage({Key key, this.title}) : super(key: key);  
      // This widget is the home page of your application.  
      final String title;  
      
      @override  
      Widget build(BuildContext context) {  
        return Scaffold(  
          appBar: AppBar(  
            title: Text(this.title),  
          ),  
          body: Center(  
            child: Text('Hello World'),  
          ),  
        );  
      }  
    }  
    </textarea></div>
                        <h2 class="h2">Types of Widget</h2>
                        <p>We can split the Flutter widget into two categories:</p>
                        <ol class="points">
                            <li>Visible (Output and Input)</li>
                            <li>Invisible (Layout and Control)</li>
                        </ol>
                        <h3 class="h3">Visible widget</h3>
                        <p>The visible widgets are related to the user input and output data. Some of the
                            important types of this widget are:</p>
                        <p class="pq"><strong>Text</strong></p>
                        <p>A Text widget holds some text to display on the screen. We can align the text
                            widget by using <strong>textAlign</strong> property, and style property allow
                            the customization of Text that includes font, font weight, font style, letter
                            spacing, color, and many more. We can use it as like below code snippets.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    new Text(   
    'Hello, Javatpoint!',   
    textAlign: TextAlign.center,     
    style: new TextStyle(fontWeight: FontWeight.bold), 
    )
    </textarea></div>
                        <p class="pq"><strong>Button</strong></p>
                        <p>This widget allows you to perform some action on click. Flutter does not allow
                            you to use the Button widget directly; instead, it uses a type of buttons like a
                            <strong>FlatButton</strong> and a <strong>RaisedButton</strong>. We can use it
                            as like below code snippets.
                        </p>
                        <div class="codeblock"><textarea name="code" class="java">
    //FlatButton Example
    new FlatButton(
      child: Text("Click here"),
      onPressed: () {
        // Do something here
      },
    ),
    
    //RaisedButton Example
    new RaisedButton(
      child: Text("Click here"),
      elevation: 5.0,
      onPressed: () {
        // Do something here
      },
    ),
    </textarea></div>
                        <p>In the above example, the <strong>onPressed</strong> property allows us to
                            perform an action when you click the button, and <strong>elevation</strong>
                            property is used to change how much it stands out.</p>
                        <p class="pq"><strong>Image</strong></p>
                        <p>This widget holds the image which can fetch it from multiple sources like from
                            the asset folder or directly from the URL. It provides many constructors for
                            loading image, which are given below:</p>
                        <ul class="points">
                            <li><strong>Image:</strong> It is a generic image loader, which is used by
                                <strong>ImageProvider</strong>.
                            </li>
                            <li><strong>asset:</strong> It load image from your project asset folder.</li>
                            <li><strong>file:</strong> It loads images from the system folder.</li>
                            <li><strong>memory: </strong>It load image from memory.</li>
                            <li><strong>network:</strong> It loads images from the network.</li>
                        </ul>
                        <p>To add an image in the project, you need first to create an assets folder where
                            you keep your images and then add the below line in
                            <strong>pubspec.yaml</strong> file.
                        </p>
                        <div class="codeblock"><textarea name="code" class="java">
    assets:
      - assets/
    </textarea></div>
                        <p>Now, add the following line in the dart file.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    Image.asset('assets/computer.png')
    </textarea></div>
                        <p>The complete source code for adding an image is shown below in the <strong>hello
                                world</strong> example.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    class MyHomePage extends StatelessWidget {
      MyHomePage({Key key, this.title}) : super(key: key);
      // This widget is the home page of your application.
      final String title;
    
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(
            title: Text(this.title),
          ),
          body: Center(
            child: Image.asset('assets/computer.png'),
          ),
        );
      }
    }
    </textarea></div>
                        <p>When you run the app, it will give the following output.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-widgets-1.png"
                            alt="Flutter Widgets" />
                        <p class="pq"><strong>Icon</strong></p>
                        <p>This widget acts as a container for storing the Icon in the Flutter. The
                            following code explains it more clearly.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    new Icon(
      Icons.add,
      size: 34.0,
    )
    </textarea></div>
                        <h3 class="h3">Invisible widget</h3>
                        <p>The invisible widgets are related to the layout and control of widgets. It
                            provides controlling how the widgets actually behave and how they will look onto
                            the screen. Some of the important types of these widgets are:</p>
                        <p class="pq"><strong>Column</strong></p>
                        <p>A column widget is a type of widget that arranges all its children's widgets in a
                            vertical alignment. It provides spacing between the widgets by using the
                            <strong>mainAxisAlignment</strong> and <strong>crossAxisAlignment</strong>
                            properties. In these properties, the main axis is the vertical axis, and the
                            cross axis is the horizontal axis.
                        </p>
                        <p><strong>Example</strong></p>
                        <p>The below code snippets construct two widget elements vertically.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    new Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: &lt;Widget&gt;[
        new Text(
          "VegElement",
        ),
        new Text(
          "Non-vegElement"
        ),
      ],
    ),
    </textarea></div>
                        <p class="pq"><strong>Row</strong></p>
                        <p>The row widget is similar to the column widget, but it constructs a widget
                            horizontally rather than vertically. Here, the main axis is the horizontal axis,
                            and the cross axis is the vertical axis.</p>
                        <p><strong>Example</strong></p>
                        <p>The below code snippets construct two widget elements horizontally.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    new Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: &lt;Widget&gt;[
        new Text(
          "VegElement",
        ),
        new Text(
          "Non-vegElement"
        ),
      ],
    ),
    </textarea></div>
                        <p class="pq"><strong>Center</strong></p>
                        <p>This widget is used to center the child widget, which comes inside it. All the
                            previous examples contain inside the center widget.</p>
                        <p><strong>Example</strong></p>
                        <div class="codeblock"><textarea name="code" class="java">
    Center(
      child: new clumn(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: &lt;Widget&gt;[
          new Text(
            "VegElement",
          ),
          new Text(
            "Non-vegElement"
          ),
        ],
      ),
    ),
    </textarea></div>
                        <p class="pq"><strong>Padding</strong></p>
                        <p>This widget wraps other widgets to give them padding in specified directions. You
                            can also provide padding in all directions. We can understand it from the below
                            example that gives the text widget padding of 6.0 in all directions.</p>
                        <p><strong>Example</strong></p>
                        <div class="codeblock"><textarea name="code" class="java">
    Padding(
      padding: const EdgeInsets.all(6.0),
      child: new Text(
        "Element 1",
      ),
    ),
    </textarea></div>
                        <p class="pq"><strong>Scaffold</strong></p>
                        <p>This widget provides a framework that allows you to add common material design
                            elements like AppBar, Floating Action Buttons, Drawers, etc.</p>
                        <p class="pq"><strong>Stack</strong></p>
                        <p>It is an essential widget, which is mainly used for <strong>overlapping</strong>
                            a widget, such as a button on a background gradient.</p>
                        <h2 class="h2">State Management Widget</h2>
                        <p>In Flutter, there are mainly two types of widget:</p>
                        <ul class="points">
                            <li>StatelessWidget</li>
                            <li>StatefulWidget</li>
                        </ul>
                        <h3 class="h3">StatefulWidget</h3>
                        <p>A StatefulWidget has state information. It contains mainly two classes: the
                            <strong>state object</strong> and the <strong>widget</strong>. It is dynamic
                            because it can change the inner data during the widget lifetime. This widget
                            does not have a <strong>build()</strong> method. It has
                            <strong>createState()</strong> method, which returns a class that extends the
                            Flutters State Class. The examples of the StatefulWidget are Checkbox, Radio,
                            Slider, InkWell, Form, and TextField.
                        </p>
                        <p class="pq"><strong>Example</strong></p>
                        <div class="codeblock"><textarea name="code" class="java">
    class Car extends StatefulWidget {
      const Car({ Key key, this.title }) : super(key: key); 
    
      @override
      _CarState createState() =&gt; _CarState();
    }
    
    class _CarState extends State&lt;Car&gt; {
      @override
      Widget build(BuildContext context) {
        return Container(
          color: const Color(0xFEEFE),
               child: Container(
                child: Container( //child: Container() )
            )
        );
      }
    }
    </textarea></div>
                        <h3 class="h3">StatelessWidget</h3>
                        <p>The StatelessWidget does not have any state information. It remains static
                            throughout its lifecycle. The examples of the StatelessWidget are Text, Row,
                            Column, Container, etc.</p>
                        <p class="pq"><strong>Example</strong></p>
                        <div class="codeblock"><textarea name="code" class="java">
    class MyStatelessCarWidget extends StatelessWidget {
      const MyStatelessCarWidget ({ Key key }) : super(key: key);
    
      @override
      Widget build(BuildContext context) {
        return Container(color: const Color(0x0xFEEFE));
      }
    }
    </textarea></div>
    
                        <hr />
    
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
                        <h1 class="h1">Flutter Layouts</h1>
                        <p>The main concept of the layout mechanism is the widget. We know that flutter
                            assume everything as a widget. So the image, icon, text, and even the layout of
                            your app are all widgets. Here, some of the things you do not see on your app
                            UI, such as rows, columns, and grids that arrange, constrain, and align the
                            visible widgets are also the widgets.</p>
                        <p>Flutter allows us to create a layout by composing multiple widgets to build more
                            complex widgets. <strong>For example</strong>, we can see the below image that
                            shows three icons with a label under each one.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-layouts.png"
                            alt="Flutter Layouts" />
                        <p>In the second image, we can see the visual layout of the above image. This image
                            shows a row of three columns, and these columns contain an icon and label.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-layouts2.png"
                            alt="Flutter Layouts" />
                        <p>In the above image, the <strong>container</strong> is a widget class that allows
                            us to customize the child widget. It is mainly used to add borders, padding,
                            margins, background color, and many more. Here, the text widget comes under the
                            container for adding margins. The entire row is also placed in a container for
                            adding margin and padding around the row. Also, the rest of the UI is controlled
                            by properties such as color, text.style, etc.</p>
                        <h2 class="h2">Layout a widget</h2>
                        <p>Let us learn how we can create and display a simple widget. The following steps
                            show how to layout a widget:</p>
                        <p><strong>Step 1:</strong> First, you need to select a Layout widget.</p>
                        <p><strong>Step 2:</strong> Next, create a visible widget.</p>
                        <p><strong>Step 3:</strong> Then, add the visible widget to the layout widget.</p>
                        <p><strong>Step 4:</strong> Finally, add the layout widget to the page where you
                            want to display.</p>
                        <h2 class="h2">Types of Layout Widgets</h2>
                        <p>We can categories the layout widget into two types:</p>
                        <ol class="points">
                            <li>Single Child Widget</li>
                            <li>Multiple Child Widget</li>
                        </ol>
                        <h3 class="h3">Single Child Widgets</h3>
                        <p>The single child layout widget is a type of widget, which can have only
                            <strong>one child widget</strong> inside the parent layout widget. These widgets
                            can also contain special layout functionality. Flutter provides us many single
                            child widgets to make the app UI attractive. If we use these widgets
                            appropriately, it can save our time and makes the app code more readable. The
                            list of different types of single child widgets are:
                        </p>
                        <p><strong>Container:</strong> It is the most popular layout widget that provides
                            customizable options for painting, positioning, and sizing of widgets.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    Center(
      child: Container(
        margin: const EdgeInsets.all(15.0),
        color: Colors.blue,
        width: 42.0,
        height: 42.0,
      ),
    )
    </textarea></div>
                        <p><strong>Padding:</strong> It is a widget that is used to arrange its child widget
                            by the given padding. It contains <strong>EdgeInsets</strong> and
                            <strong>EdgeInsets.fromLTRB</strong> for the desired side where you want to
                            provide padding.
                        </p>
                        <div class="codeblock"><textarea name="code" class="java">
    const Greetings(
      child: Padding(
        padding: EdgeInsets.all(14.0),
        child: Text('Hello JavaTpoint!'),
      ),
    )
    </textarea></div>
                        <p><strong>Center:</strong> This widget allows you to center the child widget within
                            itself.</p>
                        <p><strong>Align:</strong> It is a widget, which aligns its child widget within
                            itself and sizes it based on the child's size. It provides more control to place
                            the child widget in the exact position where you need it.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    Center(
      child: Container(
        height: 110.0,
        width: 110.0,
        color: Colors.blue,
        child: Align(
          alignment: Alignment.topLeft,
          child: FlutterLogo(
            size: 50,
          ),
        ),
      ),
    )
    </textarea></div>
                        <p><strong>SizedBox:</strong> This widget allows you to give the specified size to
                            the child widget through all screens.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    SizedBox(
      width: 300.0,
      height: 450.0,
      child: const Card(child: Text('Hello JavaTpoint!')),
    )
    </textarea></div>
                        <p><strong>AspectRatio:</strong> This widget allows you to keep the size of the
                            child widget to a specified aspect ratio.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    AspectRatio(
      aspectRatio: 5/3,
      child: Container(
        color: Colors.bluel,
      ),
    ),
    </textarea></div>
                        <p><strong>Baseline:</strong> This widget shifts the child widget according to the
                            child's baseline.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    child: Baseline(
             baseline: 30.0,
             baselineType: TextBaseline.alphabetic,
             child: Container(
                  height: 60,
                  width: 50,
                  color: Colors.blue,
             ),
    )
    </textarea></div>
                        <p><strong>ConstrainedBox:</strong> It is a widget that allows you to force the
                            additional constraints on its child widget. It means you can force the child
                            widget to have a specific constraint without changing the properties of the
                            child widget.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    ConstrainedBox(
      constraints: new BoxConstraints(
        minHeight: 150.0,
        minWidth: 150.0,
        maxHeight: 300.0,
        maxWidth: 300.0,
      ),
      child: new DecoratedBox(
        decoration: new BoxDecoration(color: Colors.red),
      ),
    ),
    </textarea></div>
                        <p><strong>CustomSingleChildLayout:</strong> It is a widget, which defers from the
                            layout of the single child to a delegate. The delegate decides to position the
                            child widget and also used to determine the size of the parent widget.</p>
                        <p><strong>FittedBox:</strong> It scales and positions the child widget according to
                            the specified <strong>fit</strong>.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    import 'package:flutter/material.dart';
    
    void main() => runApp(MyApp());
    
    class MyApp extends StatelessWidget {
      // It is the root widget of your application.
      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          title: 'Multiple Layout Widget',
          debugShowCheckedModeBanner: false,
          theme: ThemeData(
            // This is the theme of your application.
            primarySwatch: Colors.green,
          ),
          home: MyHomePage(),
        );
      }
    }
    class MyHomePage extends StatelessWidget {
    
      @override
      Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(title: Text("FittedBox Widget")),
            body: Center(
            child: FittedBox(child: Row(
              children: <Widget>[
                Container(
                  child: Image.asset('assets/computer.png'),
                  ),
                  Container(
                    child: Text("This is a widget"),
                  )
                ],
              ),
              fit: BoxFit.contain,
            )
          ),
        );
      }
    }
    </textarea></div>
                        <p><strong>Output</strong></p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-layouts3.png"
                            alt="Flutter Layouts" />
                        <p><strong>FractionallySizedBox:</strong> It is a widget that allows to sizes of its
                            child widget according to the fraction of the available space.</p>
                        <p><strong>IntrinsicHeight and IntrinsicWidth:</strong> They are a widget that
                            allows us to sizes its child widget to the child's intrinsic height and width.
                        </p>
                        <p><strong>LimitedBox:</strong> This widget allows us to limits its size only when
                            it is unconstrained.</p>
                        <p><strong>Offstage:</strong> It is used to measure the dimensions of a widget
                            without bringing it on to the screen.</p>
                        <p><strong>OverflowBox:</strong> It is a widget, which allows for imposing different
                            constraints on its child widget than it gets from a parent. In other words, it
                            allows the child to overflow the parent widget.</p>
                        <h3 class="h3">Example</h3>
                        <div class="codeblock"><textarea name="code" class="java">
    import 'package:flutter/material.dart';
    
    void main() => runApp(MyApp());
    
    class MyApp extends StatelessWidget {
      // It is the root widget of your application.
      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          title: 'Single Layout Widget',
          debugShowCheckedModeBanner: false,
          theme: ThemeData(
            // This is the theme of your application.
            primarySwatch: Colors.blue,
          ),
          home: MyHomePage(),
        );
      }
    }
    class MyHomePage extends StatelessWidget {
      
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          appBar: AppBar(
            title: Text("OverflowBox Widget"),
          ),
          body: Center(
          child: Container(
            height: 50.0,
            width: 50.0,
            color: Colors.red,
            child: OverflowBox(
              minHeight: 70.0,
              minWidth: 70.0,
              child: Container(
                height: 50.0,
                width: 50.0,
                color: Colors.blue,
                ),
              ),
            ),
          ),
        );
      }
    }
    </textarea></div>
                        <p><strong>Output</strong></p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-layouts4.png"
                            alt="Flutter Layouts" />
                        <h2 class="h2">Multiple Child widgets</h2>
                        <p>The multiple child widgets are a type of widget, which contains <strong>more than
                                one child widget</strong>, and the layout of these widgets are
                            <strong>unique</strong>. For example, Row widget laying out of its child widget
                            in a horizontal direction, and Column widget laying out of its child widget in a
                            vertical direction. If we combine the Row and Column widget, then it can build
                            any level of the complex widget.
                        </p>
                        <p>Here, we are going to learn different types of multiple child widgets:</p>
                        <p><strong>Row:</strong> It allows to arrange its child widgets in a horizontal
                            direction.</p>
                        <h3 class="h3">Example</h3>
                        <div class="codeblock"><textarea name="code" class="java">
    import 'package:flutter/material.dart';
    
    void main() => runApp(MyApp());
    
    class MyApp extends StatelessWidget {
      // It is the root widget of your application.
      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          title: 'Multiple Layout Widget',
          debugShowCheckedModeBanner: false,
          theme: ThemeData(
            // This is the theme of your application.
            primarySwatch: Colors.blue,
          ),
          home: MyHomePage(),
        );
      }
    }
    class MyHomePage extends StatelessWidget {
      @override
      Widget build(BuildContext context) {
        return Center(
          child: Container(
            alignment: Alignment.center,
            color: Colors.white,
            child: Row(
              children: <Widget>[
                Expanded(
                  child: Text('Peter', textAlign: TextAlign.center),
                ),
                Expanded(
                  child: Text('John', textAlign: TextAlign.center ),
    
                ),
                Expanded(
                  child: FittedBox(
                    fit: BoxFit.contain, // otherwise the logo will be tiny
                    child: const FlutterLogo(),
                  ),
                ),
              ],
            ),
          ),
        );
      }
    }
    </textarea></div>
                        <p><strong>Output</strong></p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-layouts5.png"
                            alt="Flutter Layouts" />
                        <p><strong>Column:</strong> It allows to arrange its child widgets in a vertical
                            direction.</p>
                        <p><strong>ListView:</strong> It is the most popular scrolling widget that allows us
                            to arrange its child widgets one after another in scroll direction.</p>
                        <p><strong>GridView:</strong> It allows us to arrange its child widgets as a
                            scrollable, 2D array of widgets. It consists of a repeated pattern of cells
                            arrayed in a horizontal and vertical layout.</p>
                        <p><strong>Expanded:</strong> It allows to make the children of a Row and Column
                            widget to occupy the maximum possible area.</p>
                        <p><strong>Table:</strong> It is a widget that allows us to arrange its children in
                            a table based widget.</p>
                        <p><strong>Flow:</strong> It allows us to implements the flow-based widget.</p>
                        <p><strong>Stack:</strong> It is an essential widget, which is mainly used for
                            overlapping several children widgets. It allows you to put up the multiple
                            layers onto the screen. The following example helps to understand it.</p>
                        <div class="codeblock"><textarea name="code" class="java">
    import 'package:flutter/material.dart';
    
    void main() => runApp(MyApp());
    
    class MyApp extends StatelessWidget {
      // It is the root widget of your application.
      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          title: 'Multiple Layout Widget',
          debugShowCheckedModeBanner: false,
          theme: ThemeData(
            // This is the theme of your application.
            primarySwatch: Colors.blue,
          ),
          home: MyHomePage(),
        );
      }
    }
    class MyHomePage extends StatelessWidget {
      @override
      Widget build(BuildContext context) {
        return Center(
          child: Container(
            alignment: Alignment.center,
            color: Colors.white,
            child: Stack(
              children: <Widget>[
                // Max Size
                Container(
                  color: Colors.blue,
                ),
                Container(
                  color: Colors.pink,
                  height: 400.0,
                  width: 300.0,
                ),
                Container(
                  color: Colors.yellow,
                  height: 220.0,
                  width: 200.0,
                )
              ],
            ),
          ),
        );
      }
    }
    </textarea></div>
                        <p><strong>Output</strong></p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-layouts6.png"
                            alt="Flutter Layouts" />
                        <h2 class="h2">Building Complex Layout</h2>
                        <p>In this section, we are going to learn how you can create a complex user
                            interface using both single and multiple child layout widgets. The layout
                            framework allows you to create a complex user interface layout by nesting the
                            rows and columns inside of rows and columns.</p>
                        <p>Let us see an example of a complex user interface by creating the <strong>product
                                list</strong>. For this purpose, you need first to replace the code of
                            <strong>main.dart</strong> file with the following code snippet.
                        </p>
                        <div class="codeblock"><textarea name="code" class="java">
    import 'package:flutter/material.dart';
    
    void main() => runApp(MyApp());
    
    class MyApp extends StatelessWidget {
      // It is the root widget of your application.
      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          title: 'Flutter Demo Application', theme: ThemeData(
          primarySwatch: Colors.green,),
          home: MyHomePage(title: 'Complex layout example'),
        );
      }
    }
    class MyHomePage extends StatelessWidget {
      MyHomePage({Key key, this.title}) : super(key: key);
      final String title;
    
      @override
      Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(title: Text("Product List")),
            body: ListView(
              padding: const EdgeInsets.fromLTRB(3.0, 12.0, 3.0, 12.0),
              children: <Widget>[
                ProductBox(
                    name: "iPhone",
                    description: "iPhone is the top branded phone ever",
                    price: 55000,
                    image: "iphone.png"
                ),
                ProductBox(
                    name: "Android",
                    description: "Android is a very stylish phone",
                    price: 10000,
                    image: "android.png"
                ),
                ProductBox(
                    name: "Tablet",
                    description: "Tablet is a popular device for official meetings",
                    price: 25000,
                    image: "tablet.png"
                ),
                ProductBox(
                    name: "Laptop",
                    description: "Laptop is most famous electronic device",
                    price: 35000,
                    image: "laptop.png"
                ),
                ProductBox(
                    name: "Desktop",
                    description: "Desktop is most popular for regular use",
                    price: 10000,
                    image: "computer.png"
                ),
              ],
            )
        );
      }
    }
    class ProductBox extends StatelessWidget {
      ProductBox({Key key, this.name, this.description, this.price, this.image}) :
            super(key: key);
      final String name;
      final String description;
      final int price;
      final String image;
    
      Widget build(BuildContext context) {
        return Container(
            padding: EdgeInsets.all(2),
            height: 110,
            child: Card(
                child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: <Widget>[
                      Image.asset("assets/" + image),
                      Expanded(
                          child: Container(
                              padding: EdgeInsets.all(5),
                              child: Column(
                                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                                children: <Widget>[
                                  Text(
                                      this.name, style: TextStyle(
                                      fontWeight: FontWeight.bold
                                  )
                                  ),
                                  Text(this.description), Text(
                                      "Price: " + this.price.toString()
                                  ),
                                ],
                              )
                          )
                      )
                    ]
                )
            )
        );
      }
    }
    </textarea></div>
                        <p>In the above code, we create widget <strong>ProductBox</strong> that contains the
                            details of the product, such as image, name, price, and description. In the
                            ProductBox widget, we use the following child widgets: Container, Row, Column,
                            Expanded, Card, Text, Image, etc. This widget contains the following layout:</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-layouts7.png"
                            alt="Flutter Layouts" />
                        <p><strong>Output</strong></p>
                        <p>Now, when we run the dart file in the android emulator, it will give the
                            following output.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-layouts8.png"
                            alt="Flutter Layouts" />
    
                        <hr />
    
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">Flutter Gestures</h1>
                        <p>Gestures are an interesting feature in Flutter that allows us to interact with
                            the mobile app (or any touch-based device). Generally, gestures define any
                            physical action or movement of a user in the intention of specific control of
                            the mobile device. Some of the examples of gestures are:</p>
                        <ul class="points">
                            <li>When the mobile screen is locked, you slide your finger across the screen to
                                unlock it.</li>
                            <li>Tapping a button on your mobile screen, and </li>
                            <li>Tapping and holding an app icon on a touch-based device to drag it across
                                screens.</li>
                        </ul>
                        <p>We use all these gestures in everyday life to interact with your phone or
                            touch-based device.</p>
                        <p>Flutter divides the gesture system into two different layers, which are given
                            below:</p>
                        <ol class="points">
                            <li>Pointers</li>
                            <li>Gestures</li>
                        </ol>
                        <h2 class="h2">Pointers</h2>
                        <p>Pointers are the first layer that represents the raw data about user interaction.
                            It has events, which describe the <strong>location</strong> and
                            <strong>movement</strong> of pointers such as touches, mice, and style across
                            the screens. Flutter does not provide any mechanism to cancel or stop the
                            pointer-events from being dispatched further. Flutter provides a
                            <strong>Listener </strong>widget to listen to the pointer-events directly from
                            the widgets layer. The pointer-events are categories into mainly four types:
                        </p>
                        <ul class="points">
                            <li>PointerDownEvents</li>
                            <li>PointerMoveEvents</li>
                            <li>PointerUpEvents</li>
                            <li>PointerCancelEvents</li>
                        </ul>
                        <p><strong>PointerDownEvents:</strong> It allows the pointer to contact the screen
                            at a particular location. </p>
                        <p><strong>PointerMoveEvents:</strong> It allows the pointer to move from one
                            location to another location on the screen. </p>
                        <p><strong>PointerUpEvents:</strong> It allows the pointer to stop contacting the
                            screen. </p>
                        <p><strong>PointerCancelEvents:</strong> This event is sent when the pointer
                            interaction is canceled. </p>
                        <h2 class="h2">Gestures</h2>
                        <p>It is the second layer that represents <strong>semantic actions </strong>such as
                            tap, drag, and scale, which are recognized from multiple individual pointer
                            events. It is also able to dispatch multiple events corresponding to gesture
                            lifecycle like drag start, drag update, and drag end. Some of the popularly used
                            gesture are listed below:</p>
                        <p><strong>Tap:</strong> It means touching the surface of the screen from the
                            fingertip for a short time and then releasing them. This gesture contains the
                            following events:</p>
                        <ul class="points">
                            <li>onTapDown</li>
                            <li>onTapUp</li>
                            <li>onTap</li>
                            <li>onTapCancel</li>
                        </ul>
                        <p><strong>Double Tap:</strong> It is similar to a Tap gesture, but you need to
                            tapping twice in a short time. This gesture contains the following events:</p>
                        <ul class="points">
                            <li>onDoubleTap</li>
                        </ul>
                        <p><strong>Drag:</strong> It allows us to touch the surface of the screen with a
                            fingertip and move it from one location to another location and then releasing
                            them. Flutter categories the drag into two types:</p>
                        <ol class="points">
                            <li><strong>Horizontal Drag:</strong> This gesture allows the pointer to move in
                                a horizontal direction. It contains the following events:
                                <ul class="points">
                                    <li>onHorizontalDragStart</li>
                                    <li>onHorizontalDragUpdate</li>
                                    <li>onHorizontalDragEnd</li>
                                </ul>
                            </li>
                            <li><strong>Vertical Drag:</strong> This gesture allows the pointer to move in a
                                vertical direction. It contains the following events:
                                <ul class="points">
                                    <li>onVerticalDragStart</li>
                                    <li>onVerticalDragStart</li>
                                    <li>onVerticalDragStart</li>
                                </ul>
                            </li>
                        </ol>
                        <p><strong>Long Press:</strong> It means touching the surface of the screen at a
                            particular location for a long time. This gesture contains the following events:
                        </p>
                        <ul class="points">
                            <li>onLongPress</li>
                        </ul>
                        <p><strong>Pan:</strong> It means touching the surface of the screen with a
                            fingertip, which can move in any direction without releasing the fingertip. This
                            gesture contains the following events:</p>
                        <ul class="points">
                            <li>onPanStart</li>
                            <li>onPanUpdate</li>
                            <li>onPanEnd</li>
                        </ul>
                        <p><strong>Pinch:</strong> It means pinching (move one's finger and thumb or bring
                            them together on a touchscreen) the surface of the screen using two fingers to
                            zoom into or out of a screen.</p>
                        <h3 class="h3">Gesture Detector</h3>
                        <p>Flutter provides a widget that gives excellent support for all types of gestures
                            by using the <strong>GestureDetector</strong> widget. The GestureWidget is
                            non-visual widgets, which is primarily used for detecting the user's gesture.
                            The basic idea of the gesture detector is a <strong>stateless</strong> widget
                            that contains parameters in its constructor for different touch events. </p>
                        <p>In some situations, there might be multiple gesture detectors at a particular
                            location on the screen, and then the framework disambiguates which gesture
                            should be called. The GestureDetector widget decides which gesture is going to
                            recognize based on which of its callbacks are non-null.</p>
                        <p>Let us learn how we can use these gestures in our application with a simple
                            <strong>onTap() </strong> event and determine how the GestureDetector processes
                            this. Here, we are going to create a <strong>box widget, </strong> design it
                            according to our desired specification, and then add the onTap() function to it.
                        </p>
                        <p>Now, create a new Flutter project and replace the following code in
                            <strong>main.dart</strong> file.
                        </p>
                        <div class="codeblock"><textarea name="code" class="java">
    import 'package:flutter/material.dart';
    
    void main() => runApp(MyApp());
    
    class MyApp extends StatelessWidget {
      // This widget is the root of your application.
      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          title: 'Flutter Demo Application', theme: ThemeData(
          primarySwatch: Colors.green,),
          home: MyHomePage(),
        );
      }
    }
    class MyHomePage extends StatefulWidget {
      @override
      MyHomePageState createState() => new MyHomePageState();
    }
    
    class MyHomePageState extends State<MyHomePage> {
      @override
      Widget build(BuildContext context) {
        return new Scaffold(
          appBar: new AppBar(
            title: new Text('Gestures Example'),
            centerTitle: true,
          ),
          body: new Center(child: GestureDetector(
              onTap: () {
                print('Box Clicked');
              },
              child: Container(
                height: 60.0,
                width: 120.0,
                padding: EdgeInsets.all(10.0),
                decoration: BoxDecoration(
                  color: Colors.blueGrey,
                  borderRadius: BorderRadius.circular(15.0),
                ),
                child: Center(child: Text('Click Me')),
              )
          )),
        );
      }
    }
    </textarea></div>
                        <p><strong>Output</strong></p>
                        <p>When you run this dart file in Android Studio, it will give the following output
                            in the emulator.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-gestures.png"
                            alt="Flutter Gestures" />
                        <p>In the above image, you can see a button with rounded edges on the center of the
                            screen. When you tap on this, it behaves like a button, and the output can be
                            seen in the console.</p>
                        <p>Flutter also provides a set of widgets that can allow you to do a specific as
                            well as advanced gestures. These widgets are given below:</p>
                        <p><strong>Dismissible:</strong> It is a type of widget that supports the flick
                            gesture to dismiss the widget.</p>
                        <p><strong>Draggable:</strong> It is a type of widget that supports drag gestures to
                            move the widget.</p>
                        <p><strong>LongPressDraggable:</strong> It is a type of widget that supports drag
                            gesture to move a widget along with its parent widget.</p>
                        <p><strong>DragTarget:</strong> It is a type of widget that can accept any<strong>
                                Draggable </strong>widget</p>
                        <p><strong>IgnorePointer:</strong> It is a type of widget that hides the widget and
                            its children from the gesture detection process.</p>
                        <p><strong>AbsorbPointer:</strong> It is a type of widget that stops the gesture
                            detection process itself. Due to this, any overlapping widget cannot able to
                            participate in the gesture detection process, and thus, no event is raised.</p>
                        <p><strong>Scrollable:</strong> It is a type of widget that supports scrolling of
                            the content which is available inside the widget.</p>
                        <h3 class="h3">Multiple Gesture Example</h3>
                        <p>In this section, we are going to see how multiple gestures work in flutter
                            applications. This demo app consists of two containers parent and child. Here,
                            everything is handled manually by using 'RawGestureDetector' and a custom
                            'GestureRecognizer' The custom GestureRecognizer provide
                            'AllowMultipleGestureRecognizer' property to the gesture list and creates a
                            'GestureRecognizerFactoryWithHandlers'. Next, when the <strong>onTap()</strong>
                            event is called, it prints text to the console.</p>
                        <p>Open the flutter project and replace the following code in the main.dart file,
                        </p>
                        <div class="codeblock"><textarea name="code" class="java">
    import 'package:flutter/gestures.dart';
    import 'package:flutter/material.dart';
    
    //It is the entry point for your Flutter app.
    void main() {
      runApp(
        MaterialApp(
          title: 'Multiple Gestures Demo',
          home: Scaffold(
            appBar: AppBar(
              title: Text('Multiple Gestures Demo'),
            ),
            body: DemoApp(),
          ),
        ),
      );
    }
    
    class DemoApp extends StatelessWidget {
      @override
      Widget build(BuildContext context) {
        return RawGestureDetector(
          gestures: {
            AllowMultipleGestureRecognizer: GestureRecognizerFactoryWithHandlers<
                AllowMultipleGestureRecognizer>(
                  () => AllowMultipleGestureRecognizer(),
                  (AllowMultipleGestureRecognizer instance) {
                instance.onTap = () => print('It is the parent container gesture');
              },
            )
          },
          behavior: HitTestBehavior.opaque,
          //Parent Container
          child: Container(
            color: Colors.green,
            child: Center(
              //Now, wraps the second container in RawGestureDetector
              child: RawGestureDetector(
                gestures: {
                  AllowMultipleGestureRecognizer:
                  GestureRecognizerFactoryWithHandlers<
                      AllowMultipleGestureRecognizer>(
                        () => AllowMultipleGestureRecognizer(),  //constructor
                        (AllowMultipleGestureRecognizer instance) {  //initializer
                      instance.onTap = () => print('It is the nested container');
                    },
                  )
                },
                //Creates the nested container within the first.
                child: Container(
                  color: Colors.deepOrange,
                  width: 250.0,
                  height: 350.0,
                ),
              ),
            ),
          ),
        );
      }
    }
    
    class AllowMultipleGestureRecognizer extends TapGestureRecognizer {
      @override
      void rejectGesture(int pointer) {
        acceptGesture(pointer);
      }
    }
    </textarea></div>
                        <p><strong>Output</strong></p>
                        <p>When you run the app, it will give the following output.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-gestures2.png"
                            alt="Flutter Gestures" />
                        <p>Next, tap on the orange box, the following output appears on your console.</p>
                        <div class="codeblock3">
                            <pre>
    It is the nested container.
    It is the parent container gesture.
    </pre>
                        </div>
    
                        <hr />
    
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>

    <div class="onlycontentinner">
        <div id="city">
            <table>
                <tr>
                    <td>
    
                        <h1 class="h1">Flutter IDE</h1>
                        <p>IDE (editors) are software programs that allow the user to create and edit text
                            files. In the development field, editors usually refer to the source code
                            editors that include many special features for writing and editing code.</p>
                        <p>We can create Flutter apps using any text editor that can easily combine with our
                            command-line tools. However, it is recommended to use editor plugins (IDE) for a
                            better experience. These plugins come with Syntax highlighting, code completion,
                            widget editing assists, run &amp; debug support, and many other features. <a
                                href="https://www.javatpoint.com/flutter">Flutter</a> supports several <a
                                href="https://www.javatpoint.com/ide-full-form">IDE</a> to build the apps.
                            Some of them are discussed below, but you can go ahead if you want to use a
                            different editor.</p>
                        <p>The most popular IDEs that give the most effective support for the Flutter
                            application development are:</p>
                        <ul class="points">
                            <li>Android Studio</li>
                            <li>IntelliJ Idea</li>
                            <li>Visual Studio</li>
                            <li>Emac</li>
                            <li>Codemagic</li>
                        </ul>
                        <p>Let us see each IDE one by one.</p>
                        <h2 class="h2">Android Studio</h2>
                        <p>It is free, open-source, and the fastest tool used to build an app on every type
                            of android device. It provides a complete experience for developing Flutter
                            applications such as code completion, navigation, syntax highlighting,
                            refactoring, widget editing assists, and run &amp; debug support, etc. The main
                            purpose of the <a href="https://www.javatpoint.com/android-studio">android
                                studio</a> is to accelerate the development process and build high-quality
                            apps for all android devices. It allows the developer to fix certain code issues
                            automatically.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-ide.jpg"
                            alt="Flutter IDE" />
                        <p>To download the android studio, <a href="https://developer.android.com/studio" rel="nofollow"
                                target="_blank">click here</a>.</p>
                        <h2 class="h2">IntelliJ Idea</h2>
                        <p><a href="https://www.javatpoint.com/intellij-idea-tutorial">IntelliJ IDEA</a> is
                            the most powerful and popular IDE among developers, which is developed and
                            maintained by <strong>JetBrains Company</strong>. It is licensed by
                            <strong>Apache 2.0</strong>. It supports many languages to develop applications.
                            It will become a favorite IDE for many developers because it supports excellent
                            plugins and a comprehensive built-in feature set. If you are going to develop an
                            application with <strong>Dart language</strong>, it acts as a prime leader
                            compared to other IDEs. It offers a complete experience for app development such
                            as smart coding assistance for Dart that includes code completion, formatting,
                            navigation, intentions, refactoring, built-in debugger, integration with pub and
                            the Dart Analysis Server. It allows us to fix certain code issues automatically.
                        </p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-ide2.png"
                            alt="Flutter IDE" />
                        <p><strong>IntelliJ Idea is mainly available in two editions</strong>:</p>
                        <ol class="points">
                            <li>Community Edition (It is free and open-source.)</li>
                            <li>Ultimate Edition (It is a paid version but free trial for 30 days)</li>
                        </ol>
                        <p>To download IntelliJ Idea, <a href="https://www.jetbrains.com/idea/download/#section=windows"
                                rel="nofollow" target="_blank">click here</a>.</p>
                        <h2 class="h2">Visual Studio Code</h2>
                        <p>Visual Studio Code or VS Code IDE is a famous editor in the market for developing
                            the Flutter application. It is free and easy to use. Most developers use this
                            IDE for Flutter application development because <strong>Microsoft's trusted
                                company backs it</strong>. It has relatively high growth and support. It
                            provides a simple Dart plugin that makes the app development faster (within 10
                            minutes or less). It offers features such as Syntax highlighting, Code
                            Completion, Realtime errors/warnings/TODOs, Pub Get Packages command, Pub
                            Upgrade Packages command, Type Hierarchy, etc. The VS code editor can work on
                            macOS, Windows, and <a href="https://www.javatpoint.com/linux-tutorial">Linux</a>.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-ide3.gif"
                            alt="Flutter IDE" />
                        <p>To download the VS Code, <a href="https://code.visualstudio.com/download" rel="nofollow"
                                target="_blank">click here</a>.</p>
                        <h2 class="h2">Emacs (Dart Mode)</h2>
                        <p>It is a lightweight IDE that provides support for app development using Flutter
                            and <a href="https://www.javatpoint.com/dart-programming">Dart</a>. It is a free
                            and open-source plugin on <strong><a
                                    href="https://www.javatpoint.com/what-is-github">GitHub</a></strong>. It
                            can be used directly in our Emacs installation for coding in Dart. It is an
                            extensible, customizable, self-documenting, and real-time display editor that
                            supports over 10000 built-in commands. Emacs can work with several operating
                            systems, such as <a href="https://www.javatpoint.com/gnu-full-form">GNU</a>,
                            GNU/Linux, MacOS, <a href="https://www.javatpoint.com/windows">Windows</a>,
                            FreeBSD, OpenBSD, and Solaris.</p>
                        <img src="https://static.javatpoint.com/tutorial/flutter/images/flutter-ide4.png"
                            alt="Flutter IDE" />
                        <p>To download the Emacs, <a href="https://www.gnu.org/software/emacs/download.html" rel="nofollow"
                                target="_blank">click here</a>.</p>
                        <h2 class="h2">Codemagic</h2>
                        <p>It is also a useful tool to develop, test, and deliver Flutter application in
                            record time. If we use the Flutter framework to develop an app, it will
                            <strong>boost</strong> the development process. It provides
                            <strong>Cinemagic</strong> to test and release the app. It also helps in
                            marketing our app without facing many issues. It is a free and open-source IDE.
                            It also allows us to contribute anything to improve its documentation.
                        </p>
                        <p>To download the Codemagic, <a href="https://codemagic.io/start/" rel="nofollow"
                                target="_blank">click here</a>.</p>
    
                        <hr />
    
    
                        <br /><br />
                    </td>
                </tr>
            </table>
        </div>
    </div>



</body>


</html>

{% endblock %}